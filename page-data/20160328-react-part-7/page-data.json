{"componentChunkName":"component---src-templates-blog-post-js","path":"/20160328-react-part-7/","result":{"data":{"site":{"siteMetadata":{"title":"Tech blog"}},"markdownRemark":{"id":"6cadb541-a883-5866-9e6e-294e51841ac9","excerpt":"在React中有一种常用的的设计模式，就是将组件分为呈现组件(presentatial component)和容器组件(container component),它们和MVC框架概念中的V和C很相似，呈现组件只负责呈现数据，而容器组件负责逻辑的处理。 现在我们创建一个示例，像系列文章第三篇的例子那样调用豆瓣图书API…","html":"<p>在React中有一种常用的的设计模式，就是将组件分为呈现组件(presentatial component)和容器组件(container component),它们和MVC框架概念中的V和C很相似，呈现组件只负责呈现数据，而容器组件负责逻辑的处理。</p>\n<p>现在我们创建一个示例，像<a href=\"/20151108-react-part-3\">系列文章第三篇</a>的例子那样调用豆瓣图书API获取信息，然后将信息呈现在页面上。首先，我们将所有逻辑写在一起，创建index.js，内容如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import React, { Component} from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nclass BookListContainer extends Component{\n  constructor() {\n    super()\n    this.state={ books:[] }\n  }\n\n  componentDidMount(){\n    var url=&quot;https://api.douban.com/v2/book/search?q=nodejs&quot;;\n    $.ajax({\n      type: &quot;GET&quot;,\n      dataType: &#39;jsonp&#39;,\n      url:url\n    }).done(function(result){\n      this.setState({books:result.books})\n    }.bind(this))\n  }\n\n  render(){\n    return(\n      &lt;ul&gt;\n        {this.state.books.map(e=&gt;&lt;li key={e.id}&gt;{e.title}&lt;/li&gt;)}\n      &lt;/ul&gt;\n    )\n  }\n}\n\nReactDOM.render(\n  &lt;BookListContainer /&gt;,\n  document.getElementById(&#39;demo7&#39;)\n)</code>\n        </deckgo-highlight-code>\n      \n<p>编译后，呈现页面如下：</p>\n<p><code>页面图片</code></p>\n<h2>代码解析</h2>\n<p>BookListContainer组件的作用是，在组件初始化完毕后，异步请求豆瓣图书API，以nodejs为关键字，搜索相关图书，并最后用html标签将数据呈现在页面上。</p>\n<p>如果按照功能划分的话，BookListContainer组件只做了两件事：获取数据和呈现数据。两种功能放在同一个组件会导致组件的复用性受到限制，因此，我们现在按照设计模式，将BookListContainer组件中呈现数据的部分抽离出来，作为一个单独的组件，叫BookListPresentation，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">class BookListPresentation extends Component {\n  render(){\n      var books = this.props.books;\n      return (\n        &lt;ul&gt;\n          {books.map(e=&gt;&lt;li key={e.id}&gt;{e.title}&lt;/li&gt;)}\n        &lt;/ul&gt;\n      )\n  }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>因此BookListContainer对render方法就不必再负责呈现逻辑，直接使用BookListPresentation组件：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">render(){\n    return(\n      &lt;BookListPresentation books={this.state.books} /&gt;\n    )\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>这样做可以让呈现组件能复用在其他地方，假如呈现逻辑改变了，直接替换掉呈现组件就可以了，这也一定程度上保证了容器组件的复用。</p>\n<p>而且，由于将呈现逻辑抽离，呈现组件内部不需要用到state或其他复杂的功能，正好适用<a href=\"/20160316-react-part-6\">前文提过的stateless写法</a>，从而进一步减少代码量，提高效率。比如此处BookListPresentation可改写为如下内容：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">var BookListPresentation = ({ books })=&gt;\n    &lt;ul&gt;\n      {books.map(e=&gt;&lt;li key={e.id}&gt;{e.title}&lt;/li&gt;)}\n    &lt;/ul&gt;</code>\n        </deckgo-highlight-code>\n      \n<h4>结语</h4>\n<p>将组件中的呈现逻辑和数据业务逻辑分离开来，可以很大程度上提高组件的复用性，而且让不需要复杂功能的呈现组件可以充分利用react特性和ES6语法糖减少代码量，提高效率。</p>\n<p>本文的示例可在<a href=\"https://github.com/twomeetings/reactExamples\">示例代码</a>的demo7目录中查阅。</p>\n<h4>参考链接</h4>\n<ol>\n<li><a href=\"https://medium.com/@learnreact/container-componentsc0e67432e005#.jww2ntlwh\">https://medium.com/@learnreact/container-componentsc0e67432e005#.jww2ntlwh</a></li>\n<li><a href=\"https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.ehf25rep4\">https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.ehf25rep4</a></li>\n</ol>","frontmatter":{"title":"React系列之七－组件间的通信－呈现组件和容器组件","date":"March 28, 2016","description":null}}},"pageContext":{"slug":"/20160328-react-part-7/","previous":{"fields":{"slug":"/20160316-react-part-6/"},"frontmatter":{"title":"React系列之六－stateless组件的写法"}},"next":{"fields":{"slug":"/20160406-react-part-8/"},"frontmatter":{"title":"React系列之八－组件的生命周期"}}}}}