{"componentChunkName":"component---src-templates-blog-post-js","path":"/20170302-redux-part-4/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"22239c39-e6f1-52a8-abd4-4571e22c1919","excerpt":"前三篇介绍了redux的用法，虽然示例代码中使用了react框架来呈现数据，但实际上两者之间并未有太多交集，而且为了结合redux框架，react的写法也不得不调整，反而造成了不便。这个问题产生的原因是少用了一个核心组件react-redux，它是react和redux框架的粘合剂。 react-redux…","html":"<p>前三篇介绍了redux的用法，虽然示例代码中使用了react框架来呈现数据，但实际上两者之间并未有太多交集，而且为了结合redux框架，react的写法也不得不调整，反而造成了不便。这个问题产生的原因是少用了一个核心组件react-redux，它是react和redux框架的粘合剂。</p>\n<p>react-redux组件的用法很简单，只有两个部分：一个是Provider组件，另一个是connect方法，本文重点讲解Provider组件。</p>\n<h3>Provider组件</h3>\n<p>在前三篇的示例中，示例代码中使用了自定义的Counter组件，可这种组件是呈现组件，没有state相关的逻辑。然而有时，组件需要在内部操作state，无法通过props属性暴露给调用方，这就需要在redux框架下编写容器组件。</p>\n<blockquote>\n<p>关于呈现组件和容器组件的概念可参考<a href=\"/20160316-react-part-6\">React系列文章之六</a></p>\n</blockquote>\n<p>由于redux将所有组件的state都存放在全局变量Store中，因此，在Rudux框架下的容器组件写法也略有不同，需要将Store通过属性props来传入。</p>\n<p>在<a href=\"/20160316-react-part-6\">React系列之二</a>的示例中有一个下拉框，通过state保存用户对颜色的选择，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">var Picker= React.createClass({\n  getInitialState(){\n    return {selectedColor:&#39;&#39;}\n  },\n  render(){\n    var color= this.state.selectedColor;\n    return(\n      &lt;div&gt;\n        &lt;select onChange={this._handleChange}&gt;\n          &lt;option value=&#39;&#39;&gt;&lt;/option&gt;\n          &lt;option value=&#39;red&#39;&gt;Red&lt;/option&gt;\n          &lt;option value=&#39;blue&#39;&gt;Blue &lt;/option&gt;\n          &lt;option value=&#39;green&#39;&gt;Green &lt;/option&gt;\n        &lt;/select&gt;\n        &lt;p&gt;selected color is : {color} &lt;/p&gt;\n      &lt;/div&gt;\n    )\n  },\n  _handleChange(event){\n    this.setState({selectedColor: event.target.value});\n  }\n})</code>\n        </deckgo-highlight-code>\n      \n<p>Store可以通过props传入到容器组件内，但是组件有时还会包含子组件，一旦层级过深，传递Store的写法会变的难以维护。因此，react-redux组件提供了一个方法，只需在外侧用Provider组件包裹住，就可以将store传递下去，写法如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import ReactDOM from &#39;react-dom&#39;\nimport {Provider} from &#39;react-redux&#39;\nimport { createStore} from &#39;redux&#39;\nimport Picker from &#39;./picker&#39;\nimport Reducer from &#39;./reducer&#39;\n\nconst store = createStore(Reducer)\nReactDOM.render(\n  &lt;Provider store={store}&gt;\n    &lt;Picker /&gt;\n  &lt;/Provider&gt;,\n  document.getElementById(&#39;demo4&#39;)\n)</code>\n        </deckgo-highlight-code>\n      \n<p>被Provider组件包裹后，内部的所有组件都可以通过this.context.store访问到全局变量Store，上面的Picker组件的render方法改动如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">  render(){\n    var { store }= this.context;\n    return(\n      &lt;select value={store.getState().selectedValue} onChange={this._handleChange.bind(this)}&gt;\n        &lt;option value=&#39;&#39;&gt;&lt;/option&gt;\n        &lt;option value=&#39;red&#39;&gt;Red&lt;/option&gt;\n        &lt;option value=&#39;blue&#39;&gt;Blue&lt;/option&gt;\n      &lt;/select&gt;\n    )\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>当需要发送Action指令来改变state状态时，可以直接调用store的实例，执行dispatch方法。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">_handleChange(event){\n    var { store }= this.context;\n    store.dispatch({type:&#39;SELECTCHANGE&#39;, value: event.target.value})\n  }</code>\n        </deckgo-highlight-code>\n      \n<h3>注意</h3>\n<p>想要在组件中通过this.context.store读取到值，除了将其包裹在Provider组件中之外，还要添加一个属性contextTypes，在本例中，写法如下。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">Picker.contextTypes = { store: React.PropTypes.object };</code>\n        </deckgo-highlight-code>\n      \n<p>Provider很少单独使用，当Provider和connect方法一起使用时，则不必添加contextTypes。</p>\n<h3>结语</h3>\n<p>在Redux架构下，必需将全局变量Store传入组件内部，才能操作state，当组件内嵌的子组件层数过多时，这种写法难以维护。通过react-redux提供的Provider组件包裹的方式，将Store传入各个组件中。</p>\n<p>本系列示例可在<a href=\"https://github.com/twomeetings/reduxExample\">此处下载</a>，本文的代码可在目录demo4中查询。</p>","frontmatter":{"title":"Redux系列之四 － 粘合剂react-redux组件（上）","date":"March 02, 2017","description":null}}},"pageContext":{"slug":"/20170302-redux-part-4/","previous":{"fields":{"slug":"/20170119-redux-part-3/"},"frontmatter":{"title":"Redux系列之三－Action的简化：bindActionCreator方法"}},"next":{"fields":{"slug":"/20170401-redux-part-5/"},"frontmatter":{"title":"Redux系列之五 － 粘合剂react-redux组件（下）"}}}},"staticQueryHashes":["2841359383"]}