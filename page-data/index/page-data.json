{"componentChunkName":"component---src-pages-index-js","path":"/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"allMarkdownRemark":{"edges":[{"node":{"excerpt":"不管你是否还学的动，JS语言依然在以自己的节奏飞快的进化。转眼间，Promise的工具包里又多了一个方法Promise.allSettled供你选择，它看起来像是对Promise.all的一种补充，缓解了使用Promise.all碰到reject…","fields":{"slug":"/2020-07-29-the-diff-between-promise-all-and-promise-allsettled/"},"frontmatter":{"date":"July 29, 2020","title":"Promise.all和Promise.allSettled的区别","description":null,"cover":{"publicURL":"/static/cover-3bf09ec83b7e9f15e982ddae3ed993f4.jpeg"}}}},{"node":{"excerpt":"日常生活中常能碰到一些商场或餐饮店提供一种需认证的wifi，这种wifi连接后不能立刻使用，往往还需要在一个页面上进一步认证操作才行，比如输入手机号填个验证码之类的。 作为一名前端开发，每当我去麦当劳店里吃饭，用手机连接wifi时，一直都很想搞清楚几个问题： 这种wifi…","fields":{"slug":"/2020-07-24-how-to-build-captive-portal-with-nodogslash/"},"frontmatter":{"date":"July 24, 2020","title":"如何搭建类似麦当劳店中需登录认证的wifi","description":null,"cover":{"publicURL":"/static/cover-d4e2b13401c6c5856cd04ee80787b974.png"}}}},{"node":{"excerpt":"在开源社区中，danger的使用尤其普遍，它可以拿来自动判断每个人提交的代码合并请求（github中叫Pull Request，下文简称PR，gitlab中叫Merge Request，下文简称MR…","fields":{"slug":"/2020-07-14-the-addicting-ci-tool-dangerjs/"},"frontmatter":{"date":"July 14, 2020","title":"试了就戒不掉的CI工具-dangerjs","description":null,"cover":{"publicURL":"/static/cover-0845e35192a767f9bc59b60ac3b0ce8f.jpeg"}}}},{"node":{"excerpt":"我前段时间参与了一个react为主的大前端项目，覆盖Web、Android、Ios三个平台。由于整个业务逻辑侧重在手机端，且Web端也是到了项目中期才开始启动，我分别以react-native和react分开建了两个项目。 可是，后端微服务集群是同一个，两个项目调用的API…","fields":{"slug":"/2020-07-10-you-should-use-lerna-for-sharing-code/"},"frontmatter":{"date":"July 10, 2020","title":"大前端项目代码重用，也许lerna是最好的选择","description":null,"cover":{"publicURL":"/static/cover-33876490d08b53714fcfd1a55aae07f8.jpeg"}}}},{"node":{"excerpt":"Hooks特性在React的16.…","fields":{"slug":"/2020-07-01-how-to-write-hooks-like-component-in-redux/"},"frontmatter":{"date":"July 01, 2020","title":"如何编写hooks风格的redux组件","description":null,"cover":{"publicURL":"/static/cover-0cee08c545fe77a26abe3c06f523b895.jpeg"}}}},{"node":{"excerpt":"每每谈到前端性能优化，大数据列表的呈现总是一个老生常谈的话题。基于浏览器本身处理DOM的方式，一旦列表数据足够大时，总是不可避免的出现CUP…","fields":{"slug":"/2020-06-18-how-to-render-big-data-with-list/"},"frontmatter":{"date":"June 18, 2020","title":"如何顺滑的展示大数据列表","description":null,"cover":{"publicURL":"/static/cover-889217ea9dd238ddb3ba5361229625ae.jpeg"}}}},{"node":{"excerpt":"看过一道面试题要求实现断点续传，当时脑海大致想了一下实现思路，没完全想通，感觉涉及的知识点挺多，于是花了些时间用react和nodejs实现了一个简易版，并梳理了实现思路和用到的知识点。 简单汇总，用到的知识点如下： 利用FileReader将上传文件切片 用MD…","fields":{"slug":"/2020-06-11-how-to-implement-resumable-upload/"},"frontmatter":{"date":"June 11, 2020","title":"web端断点续传的思路和实现","description":null,"cover":null}}},{"node":{"excerpt":"react-redux组件是React和Redux两个框架的粘合剂，它共有两个部分：Provider组件和connect方法。上篇已介绍了Provider组件，本文就来详细讲解connect方法。 connect方法 在React…","fields":{"slug":"/20170401-redux-part-5/"},"frontmatter":{"date":"April 01, 2017","title":"Redux系列之五 － 粘合剂react-redux组件（下）","description":null,"cover":null}}},{"node":{"excerpt":"前三篇介绍了redux的用法，虽然示例代码中使用了react框架来呈现数据，但实际上两者之间并未有太多交集，而且为了结合redux框架，react的写法也不得不调整，反而造成了不便。这个问题产生的原因是少用了一个核心组件react-redux，它是react和redux…","fields":{"slug":"/20170302-redux-part-4/"},"frontmatter":{"date":"March 02, 2017","title":"Redux系列之四 － 粘合剂react-redux组件（上）","description":null,"cover":null}}},{"node":{"excerpt":"Action和Action Creator Action是Redux中的核心概念之一，它是信息的载体包含跟操作指令相关的信息，因此它是一个必需包含type属性的对象，type表示我们自定义的指令类别。 发送指令需调用Store的方法dispatch…","fields":{"slug":"/20170119-redux-part-3/"},"frontmatter":{"date":"January 19, 2017","title":"Redux系列之三－Action的简化：bindActionCreator方法","description":null,"cover":null}}},{"node":{"excerpt":"前文的示例代码包含一个reducer，逻辑是state数值加1。那么当多个reducer存在时，redux是怎样在一个全局对象中管理状态的呢？现在，我们扩展例子，再添加一个Counter组件，并让两个Counter的值各自独立，相互不受影响。 代码中可以看到，第二个Counter…","fields":{"slug":"/20161104-redux-part-2/"},"frontmatter":{"date":"November 04, 2016","title":"Redux系列之二－Reducer的合并：combineReducers方法","description":null,"cover":null}}},{"node":{"excerpt":"Redux是什么？ React的开发需要配合一种前端框架来组织代码，使得项目能易于维护和扩展。大家熟知的前端框架就是MVC，然而facebook的开发人员在尝试了React＋MVC模式之后，发现其并不适合开发大型应用，便采用了一种新的前端架构，叫Flux。 但其实，Flux…","fields":{"slug":"/20160612-redux-part-1/"},"frontmatter":{"date":"June 12, 2016","title":"Redux系列之一－开篇","description":null,"cover":null}}},{"node":{"excerpt":"在系列文章第三篇中，我们谈到了组件的事件，但只提到了其中两个事件方法，其实react组件的事件方法并不多，总共只有7个，如下： 所有的这些事件拼成了react组件的生命周期，那么，在整个生命周期中，这些事件的顺序是怎样的？本文中，我创建一个示例，通过在每个事件中用console…","fields":{"slug":"/20160406-react-part-8/"},"frontmatter":{"date":"April 06, 2016","title":"React系列之八－组件的生命周期","description":null,"cover":null}}},{"node":{"excerpt":"在React中有一种常用的的设计模式，就是将组件分为呈现组件(presentatial component)和容器组件(container component),它们和MVC框架概念中的V和C…","fields":{"slug":"/20160328-react-part-7/"},"frontmatter":{"date":"March 28, 2016","title":"React系列之七－组件间的通信－呈现组件和容器组件","description":null,"cover":null}}},{"node":{"excerpt":"函数就是stateless组件 前文介绍了编写react组件的两种写法，React写法和ES6写法，除此之外还有一种编写组件的写法，而这种写法编写的组件会略有不同，这样的组件叫stateless组件。顾名思义，stateless…","fields":{"slug":"/20160316-react-part-6/"},"frontmatter":{"date":"March 16, 2016","title":"React系列之六－stateless组件的写法","description":null,"cover":null}}},{"node":{"excerpt":"从前面到文章可以知道，当我们想要编写react组件时，就需要调用React.createClass方法，这是创建组件的常用方法，但除此之外，还有两种写法经常出现在开源代码中，那就是ES6写法和stateless写法。 ES6写法 顾名思义，这种就是利用ES…","fields":{"slug":"/20160301-react-part-5/"},"frontmatter":{"date":"March 01, 2016","title":"React系列之五－ES6语法编写组件","description":null,"cover":null}}},{"node":{"excerpt":"前四篇文章介绍了webpack基本的使用之后，这一篇逐步演示一个webpack结合react的项目，其中只包含react最基本的使用，所以没用过react的不必担心。当然，也可以通过react…","fields":{"slug":"/20160226-webpack-part-5/"},"frontmatter":{"date":"February 26, 2016","title":"webpack系列之五－与react框架结合","description":null,"cover":null}}},{"node":{"excerpt":"css的提取和合并 在webpack模版插件下，可以对css做提取和合并成一个文件，从而达到优化性能和方便管理的目的。比如我们现在需要index.js文件中引入两个css文件： 提取和合并的工作就需要用到插件‘extract-text-webpack-plugin…","fields":{"slug":"/20160208-webpack-part-4/"},"frontmatter":{"date":"February 08, 2016","title":"webpack系列之四－资源文件的整合","description":null,"cover":null}}},{"node":{"excerpt":"webpack框架内置了20多种插件，除此之外的开源社区也存在很多优秀的第三方插件，利用这些插件可以轻松扩展webpack到功能，给使用者带来极大的便利。 在web开发中，模版文件基本不可或缺，它抽取出通用部分，为编写代码节省了大量的时间。在webpack…","fields":{"slug":"/20160119-webpack-part-3/"},"frontmatter":{"date":"January 19, 2016","title":"webpack系列之三 - 插件的使用","description":null,"cover":null}}},{"node":{"excerpt":"使用配置文件是webpack的基本用法，默认的配置文件名是webpack.config.js，只需把这个文件创建在根目录下，webpack编译时就会自动加载。 在开篇文章里，一个简单示例展示了webpack…","fields":{"slug":"/20160115-webpack-part-2/"},"frontmatter":{"date":"January 15, 2016","title":"webpack系列之二 - 配置文件解析","description":null,"cover":null}}},{"node":{"excerpt":"为什么要用Webpack？它是什么？ 随着nodejs的迅猛发展，javascript不断进化，且逐渐变成服务器端开发的主流，而在前端领域它能做的事情也越来越多。可是，不断增多的js代码管理起来却让人头疼，模块化是唯一的解决办法，常见的做法是将不同功能的js…","fields":{"slug":"/20160108-webpack-part-1/"},"frontmatter":{"date":"January 08, 2016","title":"webpack系列－开篇","description":"webpack系列－开篇 第一篇","cover":null}}},{"node":{"excerpt":"React系列之四－扩展知识点ref和mixin 在创建完组件后，我们常常需要获得对内部某个控件的值，比如说在系列文章第二篇中，我们在下拉框的onChange事件中获取并保存了下拉框的值，而获取值的途径是通过方法参数的属性：event.target.value…","fields":{"slug":"/20160104-react-part-4/"},"frontmatter":{"date":"January 04, 2016","title":"React系列之四－扩展知识点ref和mixin","description":null,"cover":null}}},{"node":{"excerpt":"React组件从创建到注销的过程中需要经历一个生命周期，在这个周期内会触发一系列的方法事件，利用这些事件，可以让组件处理更复杂的逻辑。 使用过jquery的一定知道，jquery的一个常见用法是，当页面DOM…","fields":{"slug":"/20151108-react-part-3/"},"frontmatter":{"date":"November 08, 2015","title":"React系列之三 － 组件的事件","description":null,"cover":null}}},{"node":{"excerpt":"大多数情况下，我们创建的组件不需要用到state，只需处理props属性，然后将其呈现出来。但是有时组件中需要应对用户的输入，这时就必须用到state来保存变化的值。 我们现在创建一个含有下拉框的组件，当用户选择了下拉框时，用state记录用户选择的内容。现在创建index.js…","fields":{"slug":"/20150721-react-part-2/"},"frontmatter":{"date":"July 21, 2015","title":"React系列之二 － state","description":null,"cover":null}}},{"node":{"excerpt":"前言 React是Facebook公司创建的框架，起始于2011年，起初只在其公司内部使用，在2012年应用于Instagram项目，之后于2013年5月开源。紧接着基于React框架基础上，facebook又推出来React Native框架用于Ios和Android…","fields":{"slug":"/20150712-react-part-1/"},"frontmatter":{"date":"July 12, 2015","title":"React系列之一 － 开篇","description":null,"cover":null}}}]}},"pageContext":{}},"staticQueryHashes":["2841359383"]}