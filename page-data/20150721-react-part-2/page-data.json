{"componentChunkName":"component---src-templates-blog-post-js","path":"/20150721-react-part-2/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"4b0d98d1-1bd9-5a4d-8fd9-15b177708e64","excerpt":"大多数情况下，我们创建的组件不需要用到state，只需处理props属性，然后将其呈现出来。但是有时组件中需要应对用户的输入，这时就必须用到state来保存变化的值。 我们现在创建一个含有下拉框的组件，当用户选择了下拉框时，用state记录用户选择的内容。现在创建index.js，内容如下： state…","html":"<p>大多数情况下，我们创建的组件不需要用到state，只需处理props属性，然后将其呈现出来。但是有时组件中需要应对用户的输入，这时就必须用到state来保存变化的值。</p>\n<p>我们现在创建一个含有下拉框的组件，当用户选择了下拉框时，用state记录用户选择的内容。现在创建index.js，内容如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nvar UserInput= React.createClass({\n  getInitialState(){\n    return {selectedColor:&#39;&#39;}\n  },\n  render(){\n    var color= this.state.selectedColor;\n    return(\n      &lt;div&gt;\n        &lt;select onChange={this._handleChange}&gt;\n          &lt;option value=&#39;&#39;&gt;&lt;/option&gt;\n          &lt;option value=&#39;red&#39;&gt;Red&lt;/option&gt;\n          &lt;option value=&#39;blue&#39;&gt;Blue &lt;/option&gt;\n          &lt;option value=&#39;green&#39;&gt;Green &lt;/option&gt;\n        &lt;/select&gt;\n        &lt;p&gt;selected color is : {color} &lt;/p&gt;\n      &lt;/div&gt;\n    )\n  },\n  _handleChange(event){\n    this.setState({selectedColor: event.target.value});\n  }\n})\n\nReactDOM.render(\n  &lt;UserInput /&gt;,\n  document.getElementById(&#39;demo2&#39;)\n)</code>\n        </deckgo-highlight-code>\n      \n<h3>state初始化</h3>\n<p>从代码中可以看出，UserInput组件和<a href=\"/20150712-react-part-1\">上一篇</a>的例子相比，多了getInitialState方法，该方法通过返回一个对象来初始化state，最终对象的属性和state属性一致。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">getInitialState(){\n    return {selectedColor:&#39;&#39;}\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>状态值的读取和props相似，不同的是要用state保留字。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">var color= this.state.selectedColor;</code>\n        </deckgo-highlight-code>\n      \n<h3>state修改</h3>\n<p>state的修改有别于以往常见的修改方法，它不是直接操作对象this.state，而是创建新的对象将原对象替换，使用方法this.setState。</p>\n<p>在示例中的onChange事件中，直接将下拉框选中的值赋予state的selectedColor属性。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">this.setState({selectedColor: event.target.value});</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p>event是onChange事件的参数，event.target.value是常用属性，用来读取修改后的控件参数，其他的属性可参考<a href=\"https://facebook.github.io/react/docs/events.html#form-events\">官网此处</a></p>\n</blockquote>\n<h2>props和state的比较</h2>\n<p>props和state在组件中都可以用来承载数据，不过它们是有区别的。</p>\n<p>props通常由外部调用时指定，一旦定下就不可更改，因此它常常和初始化联系到一起。不可更改的特性也意味着更好的性能。react开发中有一种开发模式就是父子组件，父组件和子组件之间的通信基本通过props。</p>\n<p>state在组件内部操作，是可变的，常常用来应对有用户输入的场景，比如本例中用来记录下拉框选中的值。每次state的值改变，整个组件就会重新呈现一次，过于频繁的改动有可能会导致性能问题。</p>\n<blockquote>\n<p>可查看<a href=\"https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#components-are-just-state-machines\">官方网站</a>给出的使用state的建议。</p>\n</blockquote>\n<h3>示例代码</h3>\n<p>本篇的<a href=\"https://github.com/twomeetings/reactExamples\">示例代码</a>可在demo2文件夹中查找。</p>","frontmatter":{"title":"React系列之二 － state","date":"July 21, 2015","description":null,"cover":null}}},"pageContext":{"slug":"/20150721-react-part-2/","previous":{"fields":{"slug":"/20150712-react-part-1/"},"frontmatter":{"title":"React系列之一 － 开篇"}},"next":{"fields":{"slug":"/20151108-react-part-3/"},"frontmatter":{"title":"React系列之三 － 组件的事件"}}}},"staticQueryHashes":["2841359383"]}