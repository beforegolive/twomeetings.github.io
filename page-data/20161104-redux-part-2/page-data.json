{"componentChunkName":"component---src-templates-blog-post-js","path":"/20161104-redux-part-2/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"d1e6cbd4-dbc6-5337-a0cc-cfa8e6fe0019","excerpt":"前文的示例代码包含一个reducer，逻辑是state数值加1。那么当多个reducer存在时，redux是怎样在一个全局对象中管理状态的呢？现在，我们扩展例子，再添加一个Counter组件，并让两个Counter的值各自独立，相互不受影响。 代码中可以看到，第二个Counter组件点击时，发送的Action…","html":"<p>前文的示例代码包含一个reducer，逻辑是state数值加1。那么当多个reducer存在时，redux是怎样在一个全局对象中管理状态的呢？现在，我们扩展例子，再添加一个Counter组件，并让两个Counter的值各自独立，相互不受影响。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">// index.js\n  ReactDOM.render(\n    &lt;div&gt;\n      &lt;Counter\n        value = {store.getState()}\n        handleClick={()=&gt; store.dispatch({type:&#39;INCREMENT&#39;})}\n      /&gt;\n      &lt;Counter\n        value = {store.getState()}\n        handleClick={()=&gt; store.dispatch({type:&#39;OTHER_INCREMENT&#39;})}\n      /&gt;\n    &lt;/div&gt;\n    ,\n    document.getElementById(&#39;demo2&#39;)\n  )\n}</code>\n        </deckgo-highlight-code>\n      \n<p>代码中可以看到，第二个Counter组件点击时，发送的Action类型和第一个不同，因为redux的机制，对Action多逻辑处理都放在在了Reducer中。在之前的reducer.js文件中，只有一个方法counterReducer，并且通过ES6语法将全局state初始化成了数值0，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">function counterReducer(state = 0, action){\n  // ...\n}</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p>关于ES6中对方法参数的初始化写法，可参考阮一峰老师的<a href=\"http://es6.ruanyifeng.com/\">ES6入门</a></p>\n</blockquote>\n<p>记录多个值需要用到对象或数组，而常见的写法是将全局state当作对象，因此原方法counterReducer的逻辑需做修改，用state对象的value属性来记录数值。对于第二个组件，用otherValue属性来记录对应的值，这样可以保证两个组件不会冲突，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">function counterReducer(state = { value:0, otherValue:0 }, action){\n  state.value =  state.value || 0;\n  switch (action.type) {\n    case &#39;INCREMENT&#39;:\n      state.value++;\n      return state;\n    case &#39;OTHER_INCREMENT&#39;:\n      state.otherValue++;\n      return state;\n    default:\n      return state;\n  }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>此时的全局变量state结构如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">{\n\tvalue:0,\n\totherValue:0\n}</code>\n        </deckgo-highlight-code>\n      \n<p>编译后页面如下：</p>\n<p><img src=\"http://7xtbg7.com2.z0.glb.clouddn.com/redux2-1\"></p>\n<h3>conbineReducers－解决属性冲突</h3>\n<p>在同一个reducer中，修改属性名比较容易，比如上文中，我们用不同的属性名value和otherValue避免组件的冲突。但是，项目中通常存在多个组件，这些组件相关的reducer写在不同的方法中，这种情况容易出现属性名冲突，且难以修改。比如，现在我们再引入第三个Counter组件，且该组件对应另一个reducer方法，也同样用value属性名来保存值，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">// reducer.js\nexport function counterReducer(state = { value:0, otherValue:0}, action){\n  state.value =  state.value || 0;\n  switch (action.type) {\n    case &#39;INCREMENT&#39;:\n      state.value++;\n      return state;\n    case &#39;OTHER_INCREMENT&#39;:\n      state.otherValue++;\n      return state;\n    default:\n      return state;\n  }\n}\n\nexport function secondReducer(state={ value:0 }, action){\n  switch (action.type) {\n    case &#39;DOUBLE_INCREMENT&#39;:\n      state.value= state.value+2;\n      return state;\n    default:\n      return state;\n  }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>redux提供了conbineReducers方法来应对多个reducer合并成一个，从而解决属性名冲突的情况，用法如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import {createStore, combineReducers} from &#39;redux&#39;\nimport {counterReducer, secondReducer} from &#39;./reducer.js&#39;\n\nvar reducers=combineReducers({counterReducer,secondReducer})\n\nconst store = createStore(reducers)</code>\n        </deckgo-highlight-code>\n      \n<p>conbineReducers在全局对象中添加了与方法名对应的属性，通过这种方法解决了冲突问题。此时全局对象state的解构如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">{\n\tcounterReducer: { value:0, otherValue:0},\n\tsecondReducer: { value:0 }\n}</code>\n        </deckgo-highlight-code>\n      \n<p>在这种情况下，组件初始化时传入的值也要加方法前缀，比如state.counterReducer.value。因此引用组件的入口文件index.js也要做相应调整，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">ReactDOM.render(\n    &lt;div&gt;\n      &lt;Counter\n        value = {state.counterReducer.value}\n        handleClick={()=&gt; store.dispatch({type:&#39;INCREMENT&#39;})}\n      /&gt;\n      &lt;Counter\n        value = {state.counterReducer.otherValue}\n        handleClick={()=&gt; store.dispatch({type:&#39;OTHER_INCREMENT&#39;})}\n      /&gt;\n      &lt;Counter\n        value = {state.secondReducer.value}\n        handleClick={()=&gt; store.dispatch({type:&#39;DOUBLE_INCREMENT&#39;})}\n      /&gt;\n    &lt;/div&gt;\n    ,\n    document.getElementById(&#39;demo2&#39;)\n  )</code>\n        </deckgo-highlight-code>\n      \n<h3>结语</h3>\n<p>本文详细解释了当所有组件的state都放在一个全局变量时不可避免的属性名冲突问题，以及如何通过redux提供的conbineReducers方法解决此问题。</p>\n<p>代码示例可在<a href=\"https://github.com/twomeetings/reduxExample\">此处下载</a>，在目录demo2中可找到本文示例。</p>","frontmatter":{"title":"Redux系列之二－Reducer的合并：combineReducers方法","date":"November 04, 2016","description":null,"cover":null}}},"pageContext":{"slug":"/20161104-redux-part-2/","previous":{"fields":{"slug":"/20160612-redux-part-1/"},"frontmatter":{"title":"Redux系列之一－开篇"}},"next":{"fields":{"slug":"/20170119-redux-part-3/"},"frontmatter":{"title":"Redux系列之三－Action的简化：bindActionCreator方法"}}}},"staticQueryHashes":["2841359383"]}