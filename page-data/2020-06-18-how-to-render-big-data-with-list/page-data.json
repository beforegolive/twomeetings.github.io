{"componentChunkName":"component---src-templates-blog-post-js","path":"/2020-06-18-how-to-render-big-data-with-list/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"74df2d3e-8f2e-50fb-ac4d-72956eafcd86","excerpt":"每每谈到前端性能优化，大数据列表的呈现总是一个老生常谈的话题。基于浏览器本身处理DOM的方式，一旦列表数据足够大时，总是不可避免的出现CUP和内存占用导致的卡顿问题，因此，针对大数据列表，只能使用特别的方式来呈现。 面对这个问题时，直觉反应就是切分：切成小块再呈现。比如，现在有10万条数据，仅仅拿出前100…","html":"<p>每每谈到前端性能优化，大数据列表的呈现总是一个老生常谈的话题。基于浏览器本身处理DOM的方式，一旦列表数据足够大时，总是不可避免的出现CUP和内存占用导致的卡顿问题，因此，针对大数据列表，只能使用特别的方式来呈现。</p>\n<p>面对这个问题时，直觉反应就是切分：切成小块再呈现。比如，现在有10万条数据，仅仅拿出前1000条呈现出来，随着滚动条的滑动再逐步展示后面数据。然而，这种方式引起的列表高度变化会给用户带来非常糟糕的滑动体验，无论是补充数据还是把原列表换掉，使用起来跟标准滚动条差别非常大。因此，仅仅是切分还远远不够。</p>\n<h3>定高</h3>\n<p>为了防止列表高度变化带来的滚动体验问题，需要在大列表呈现时就先计算好高度。也就是说当要呈现10万条数据时，即使只先呈现前1000条，10W条数据的总高度要先被算好并设置在最外层的容器上。目的是当滑动时，呈现的数据变化，但容器总高度不变，这样体验起来才会和普通滚动条一致。</p>\n<p>给10万条数据定高，就意味着你需要知道每一条数据呈现出来的高度是多少，在代码实现层面，可以拿出其中一条数据展示出来获取其高度。如此一来，不但总容器的高度能确定，每一条数据在纵坐标的起始位置也能定下，为后续的滑动展示提供基础。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8d0de108ece3883208850a15d8d27150/c9069/big-list-1.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 84.45945945945947%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAARABQDASIAAhEBAxEB/8QAGAABAAMBAAAAAAAAAAAAAAAAAAEDBAb/xAAYAQADAQEAAAAAAAAAAAAAAAAAAwQBAv/aAAwDAQACEAMQAAAB7qjZhjZqQo4tDMAP/8QAGRABAQEBAQEAAAAAAAAAAAAAAQIDEQAQ/9oACAEBAAEFAnSR1tKh7HtZW8zkff/EABsRAAAHAQAAAAAAAAAAAAAAAAABAhAREiEx/9oACAEDAQE/AUVnQfX/AP/EAB4RAAAEBwAAAAAAAAAAAAAAAAEDETEABBASEyJh/9oACAECAQE/AZnMBej8gtbAV6//xAAZEAEAAgMAAAAAAAAAAAAAAAABABEQICH/2gAIAQEABj8CqUQccIaf/8QAGhABAQACAwAAAAAAAAAAAAAAAREAIRAgMf/aAAgBAQABPyHYGU5qYzHvFciTEEken//aAAwDAQACAAMAAAAQOOg8/8QAGBEBAAMBAAAAAAAAAAAAAAAAEQAQUWH/2gAIAQMBAT8QTLsKL//EABsRAQEAAQUAAAAAAAAAAAAAABEBcQAQIZHB/9oACAECAQE/EGLSoCp3fNY2jk53/8QAGxABAQADAAMAAAAAAAAAAAAAAREAECExcZH/2gAIAQEAAT8QqSWxTwYcgg8Ux+ahv3XKUChjdgtH3p1//9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"通过单项定高\"\n        title=\"通过单项定高\"\n        src=\"/static/8d0de108ece3883208850a15d8d27150/625aa/big-list-1.jpg\"\n        srcset=\"/static/8d0de108ece3883208850a15d8d27150/c4d45/big-list-1.jpg 148w,\n/static/8d0de108ece3883208850a15d8d27150/1f0d7/big-list-1.jpg 295w,\n/static/8d0de108ece3883208850a15d8d27150/625aa/big-list-1.jpg 590w,\n/static/8d0de108ece3883208850a15d8d27150/f8367/big-list-1.jpg 885w,\n/static/8d0de108ece3883208850a15d8d27150/c9069/big-list-1.jpg 1124w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<h3>分组</h3>\n<p>一旦高度定下，就可以根据滚动条的的位置展示或隐藏列表数据，但具体的代码实现却不得不考虑性能问题，因为需要遍历整个列表逐个判断，10W条数据遍历一次也是特别大的运算，更糟糕的是，滚动条滑动的事件触发是非常频繁的。</p>\n<p>解决方案就是分组，即将100个或1000个划分为一组，以组为单位进行判断，同时，需要在定高时根据每一项高度计算出组的纵坐标起始位置。如此一来，遍历时以组为单位大大减少了计算量，10W条数据，1000个为1组，遍历起来也就只有100组而已。</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6b617981183c6ba40139498670c9efb8/8f888/big-list-2.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.67567567567568%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAAPABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAMEBv/EABYBAQEBAAAAAAAAAAAAAAAAAAIDBP/aAAwDAQACEAMQAAAB3CLJcjcBc//EABkQAAMBAQEAAAAAAAAAAAAAAAECAxESAP/aAAgBAQABBQI1G1YhpHU5X1ULNMcp/8QAGREAAQUAAAAAAAAAAAAAAAAAAAECERIx/9oACAEDAQE/AW1kXT//xAAaEQACAwEBAAAAAAAAAAAAAAABAwAREjGh/9oACAECAQE/AWh2DXkXeBrs/8QAGBABAAMBAAAAAAAAAAAAAAAAAAERITH/2gAIAQEABj8CY1yGKl//xAAaEAEBAQEAAwAAAAAAAAAAAAABABFBIVHR/9oACAEBAAE/IQZjInMkNXbb5Q1HjPc/Q2//2gAMAwEAAgADAAAAEEzv/8QAGBEBAQADAAAAAAAAAAAAAAAAEQABMaH/2gAIAQMBAT8QyB7FGr//xAAbEQEAAgIDAAAAAAAAAAAAAAABABEhMUFxsf/aAAgBAgEBPxB4LNlaPsJHgL7n/8QAGRABAQEBAQEAAAAAAAAAAAAAAREAQSEx/9oACAEBAAE/EEzGDFxSUXxnXPAURXKFUX6xiDoJx1xwAoy3f//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"big list 2\"\n        title=\"big list 2\"\n        src=\"/static/6b617981183c6ba40139498670c9efb8/625aa/big-list-2.jpg\"\n        srcset=\"/static/6b617981183c6ba40139498670c9efb8/c4d45/big-list-2.jpg 148w,\n/static/6b617981183c6ba40139498670c9efb8/1f0d7/big-list-2.jpg 295w,\n/static/6b617981183c6ba40139498670c9efb8/625aa/big-list-2.jpg 590w,\n/static/6b617981183c6ba40139498670c9efb8/f8367/big-list-2.jpg 885w,\n/static/6b617981183c6ba40139498670c9efb8/8f888/big-list-2.jpg 1104w\"\n        sizes=\"(max-width: 590px) 100vw, 590px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n      />\n  </a>\n    </span></p>\n<p>分组后，滑动展示时便可以灵活制定展示规则，比如滚动条划过当前组高度一大半以后展示下一组等。</p>\n<p><img src=\"/538832524e510d1242a0e68c853458e1/big-list-3.gif\" alt=\"分组后的滑动展示预览图\"></p>\n<h3>分组算法</h3>\n<p>因为看了国外一篇写大数据列表的文章有感，才写了此文。值得一提的是，那篇文章中的分组方式很特别，利用二叉树算法，一个简洁递归就把数据分好了。</p>\n\n        <deckgo-highlight-code language=\"javascript\" >\n          <code slot=\"code\">recursiveSplit =(data)=&gt; {\n    if(data.length / 2 &gt; this.minimumStackSize) {\n      let mid = Math.floor(data.length/2, 10);\n      let node = { \n        parent: true,\n        getParent: ()=&gt; data,\n        data: [this.recursiveSplit(data.slice(0, mid)), this.recursiveSplit(data.slice(mid, data.length+1))]\n      }\n      return node;\n    }\n    return {\n      parent: false,\n      data\n    }\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>作者最终Demo的效果如图，相关链接我已贴在文章底部。</p>\n<p><img src=\"/c624386ba3fb8f16eb0eeda4a2015237/big-list-4.gif\" alt=\"demo效果展示图\"></p>\n<h3>结语</h3>\n<p>处理大数据列表的呈现，关键点有两个，一是定高，二是分组。定高保证了选择性呈现数据时滚动条的正常体验，分组则处理了频繁遍历带来的性能消耗。</p>\n<h5>参考资料：</h5>\n<p><a href=\"https://medium.com/better-programming/how-i-rendered-a-massive-list-in-react-without-memory-and-cpu-issues-7ac6fe6a697b\">https://medium.com/better-programming/how-i-rendered-a-massive-list-in-react-without-memory-and-cpu-issues-7ac6fe6a697b</a></p>\n<p><a href=\"https://react-eternal-list.rinas.in/\">https://react-eternal-list.rinas.in/</a></p>\n<p><a href=\"https://github.com/rinasm/react-eternal-list#readme\">https://github.com/rinasm/react-eternal-list#readme</a></p>\n<p><img src=\"https://user-gold-cdn.xitu.io/2020/7/1/17308da600ad738a?w=1702&#x26;h=806&#x26;f=png&#x26;s=162909\"></p>","frontmatter":{"title":"如何顺滑的展示大数据列表","date":"June 18, 2020","description":null,"cover":{"publicURL":"/static/cover-889217ea9dd238ddb3ba5361229625ae.jpeg"}}}},"pageContext":{"slug":"/2020-06-18-how-to-render-big-data-with-list/","previous":{"fields":{"slug":"/2020-06-11-how-to-implement-resumable-upload/"},"frontmatter":{"title":"web端断点续传的思路和实现"}},"next":{"fields":{"slug":"/2020-07-01-how-to-write-hooks-like-component-in-redux/"},"frontmatter":{"title":"如何编写hooks风格的redux组件"}}}},"staticQueryHashes":["2841359383"]}