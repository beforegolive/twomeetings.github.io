{"componentChunkName":"component---src-templates-blog-post-js","path":"/20160301-react-part-5/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"b8bb9fb3-a284-5298-b4f0-c8caef8a4339","excerpt":"从前面到文章可以知道，当我们想要编写react组件时，就需要调用React.createClass方法，这是创建组件的常用方法，但除此之外，还有两种写法经常出现在开源代码中，那就是ES6写法和stateless写法。 ES6写法 顾名思义，这种就是利用ES6的语法来编写组件，详细的ES…","html":"<p>从前面到文章可以知道，当我们想要编写react组件时，就需要调用React.createClass方法，这是创建组件的常用方法，但除此之外，还有两种写法经常出现在开源代码中，那就是ES6写法和stateless写法。</p>\n<h3>ES6写法</h3>\n<p>顾名思义，这种就是利用ES6的语法来编写组件，详细的ES6语法可参考阮一峰老师的<a href=\"http://es6.ruanyifeng.com/\">ECMAScript 6入门</a>，这里不再赘述。</p>\n<p>本文用ES6写法来编写上篇文章的示例，以方便比较两者之间的不同。创建index.js，内容如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import React, { Component} from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\nimport Mixin from &#39;react-mixin&#39;\n\nlet mixinObject={\n  componentDidMount(){\n    this._alertMessage(&#39;completed&#39;);\n  },\n  _alertMessage(msg){\n    alert(msg);\n  }\n}\n\nclass InputButton extends Component {\n  constructor() {\n    super()\n    this.state={\n      val:&#39;&#39;\n    }\n    Mixin.onClass(InputButton, mixinObject);\n  }\n\n  render(){\n    var val=this.state.val;\n    return(\n      &lt;div&gt;\n        &lt;input ref={c=&gt;this._input=c }/&gt;\n        &lt;button onClick={this._handleClick.bind(this)}&gt;go Button&lt;/button&gt;\n        &lt;p&gt;input value : &lt;b&gt;{val}&lt;/b&gt;&lt;/p&gt;\n      &lt;/div&gt;\n    )\n  }\n\n  _handleClick(){\n    this.setState({val: this._input.value})\n  }\n}\n\nReactDOM.render(\n  &lt;InputButton /&gt;,\n  document.getElementById(&#39;demo5&#39;)\n)</code>\n        </deckgo-highlight-code>\n      \n<h3>两种写法的区别</h3>\n<p>可参考上篇中的写法，在这里比较两种组件写法之间的差别。为方便说明，在这里称React.createClass创建组件的写法为React写法，而利用ES6语法创建组件的写法则称为ES6写法。</p>\n<h4>组件的声明</h4>\n<p>在ES6写法中组件被看作是类，通过类的声明来创建组件，类必须要继承React.Component组件，类名就是要创建的组件名。因为是类，方法和属性之间不必添加逗号。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">class InputButton extends React.Component {}</code>\n        </deckgo-highlight-code>\n      \n<p>而React写法中，组件是React.createClass方法的返回值，由组件名是变量的名字。由于组件的属性和方法来自于一个对象，因此需要用逗号隔开。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">var InputButton=React.createClass({})</code>\n        </deckgo-highlight-code>\n      \n<h4>state的初始化</h4>\n<p>在ES6写法中，初始化的工作要放在类的构造函数里，即constructor方法。在构造函数中，只需对this.state赋值一个对象就完成来state的初始化。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">constructor() {\n    super()\n    this.state={\n      val:&#39;&#39;\n    }\n }</code>\n        </deckgo-highlight-code>\n      \n<p> 在React写法中，初始化state则需要用getInitialState方法。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">getInitialState(){\n   return { val: &#39;&#39;}\n }</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p>在ES6写法里，假如类有父类，则构造函数第一句必须是super()，用来初始化父类的相关信息，否则会出错。</p>\n</blockquote>\n<h4>props的默认值</h4>\n<p>ES6的类声明中，无法设置props的默认值，只能在类的主体之外，使用defaultProps属性，来完成对默认值的设置。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">class InputButton extends React.Component{...}\nInputButton.defaultProps = { initialCount: 0 };</code>\n        </deckgo-highlight-code>\n      \n<p>在React写法中，通过getDefaultProps方法来完成默认值的设置。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">\tgetDefaultProps(){\n\t\treturn { initialCount: 0 };\n\t}</code>\n        </deckgo-highlight-code>\n      \n<h4>propTypes的写法</h4>\n<p>在<a href=\"/20150712-react-part-1\">此系列文章第一篇</a>)我们提到了propTypes，它可以对组件所需要的属性做验证，从而让组件的调用方了解如何正确使用该组件，当时的React写法是：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">propTypes:{\n    year: PropTypes.number.isRequired\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>而ES6的写法与设置props的默认值类似，需要在类的主体之外，用propTypes属性来设置，写法如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">class InputButton extends React.Component{...}\nInputButton.propTypes = {\n\tyear: PropTypes.number.isRequired\n};</code>\n        </deckgo-highlight-code>\n      \n<h4>对mixin的支持</h4>\n<p><a href=\"/20160104-react-part-4\">上篇文章</a>中，我们用React写法创建的组件中通过设置mixins属性，添加了mixin功能，让两个不相干的类之间也能共享属性和方法。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">var InputButton=React.createClass({\n  mixins:[mixinObject],\n  getInitialState(){\n    return { val: &#39;&#39;}\n  },</code>\n        </deckgo-highlight-code>\n      \n<p>可惜的是，ES6写法目前并不支持mixin，只能通过第三方的组件来实现mixin。本例中使用了react-mixin组件来添加mixin功能，写法如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import Mixin from &#39;react-mixin&#39;\nclass InputButton extends Component {\n  constructor() {\n    super()\n    this.state={\n      val:&#39;&#39;\n    }\n    Mixin.onClass(InputButton, mixinObject);\n  }  </code>\n        </deckgo-highlight-code>\n      \n<p> 除此之外，还有其他的第三方组件提供mixin功能，而且在不久的将来，ES7的语法中也会加入了对mixin的支持。所以从目前来看，当你需要mixin功能的组件时，选择React写法会比较有利。</p>\n<blockquote>\n<p> react－mixin组件的详细信息可<a href=\"https://github.com/brigand/react-mixin\">点击此处查看</a></p>\n</blockquote>\n<h4>方法绑定this</h4>\n<p>在本例的ES6写法中，button控件的onClick事件和React写法略有不同，在方法的最后多了.bind(this)。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">&lt;button onClick={this._handleClick.bind(this)}&gt;go Button&lt;/button&gt;</code>\n        </deckgo-highlight-code>\n      \n<p>bind是javscript自带的方法，bind(this)的作用是为了让对应方法的内部实现能通过this引用到当前组件的实例。所以在本例中是为了让_handleClick方法内部能够使用this.setState方法。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">_handleClick(){\n    this.setState({val: this._input.value})\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>相似的写法还有this.props，this.state等等，假如组件中的方法内部通过this引用了实例的属性和方法，在ES6写法中就必须在最后添加.bind(this)，否则会出错。</p>\n<p>React写法不需要bind(this)，因为React.createClass()会将参数对象中的所有方法都自动绑定.bind(this)，换言之，React写法也需要绑定this，但createClass帮我们做了绑定的逻辑，省去了手工编写的麻烦。</p>\n<p>但是假如方法内部的方法也需要引用组件示例的方法（比如this.setState）该怎么办？这种情况createClass不能帮忙自动绑定，只能自己手动操作。在之前的<a href=\"http://twomeetings.github.io/2016/03/03/React%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%EF%BC%8D%E4%BA%8B%E4%BB%B6/\">系列文章－组件的事件</a>中，有一段jQuery异步请求的代码，在回调函数中使用了this.setState，所以在方法后面添加了.bind(this)。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">$.ajax({\n        type: &quot;GET&quot;,\n        dataType: &#39;jsonp&#39;,\n        url: url\n      }).done(function(json){\n        var rating = json.rating.average;\n        this.setState({rating:rating});\n      }.bind(this));</code>\n        </deckgo-highlight-code>\n      \n<h3>示例代码</h3>\n<p>本文的代码可查看<a href=\"https://github.com/twomeetings/reactExamples\">示例代码</a>的demo5目录。</p>","frontmatter":{"title":"React系列之五－ES6语法编写组件","date":"March 01, 2016","description":null}}},"pageContext":{"slug":"/20160301-react-part-5/","previous":{"fields":{"slug":"/20160226-webpack-part-5/"},"frontmatter":{"title":"webpack系列之五－与react框架结合"}},"next":{"fields":{"slug":"/20160316-react-part-6/"},"frontmatter":{"title":"React系列之六－stateless组件的写法"}}}},"staticQueryHashes":["2841359383"]}