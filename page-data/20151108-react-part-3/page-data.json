{"componentChunkName":"component---src-templates-blog-post-js","path":"/20151108-react-part-3/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"259bf63f-32a6-59ab-87af-4db191850722","excerpt":"React组件从创建到注销的过程中需要经历一个生命周期，在这个周期内会触发一系列的方法事件，利用这些事件，可以让组件处理更复杂的逻辑。 使用过jquery的一定知道，jquery的一个常见用法是，当页面DOM元素加载完成后，再开始一些逻辑操作，写法如下： 那么，这个功能在react…","html":"<p>React组件从创建到注销的过程中需要经历一个生命周期，在这个周期内会触发一系列的方法事件，利用这些事件，可以让组件处理更复杂的逻辑。</p>\n<p>使用过jquery的一定知道，jquery的一个常见用法是，当页面DOM元素加载完成后，再开始一些逻辑操作，写法如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">$(function(){\n\t// do something\n})</code>\n        </deckgo-highlight-code>\n      \n<p>那么，这个功能在react中该怎样实现呢？答案是通过事件中的componentDidMount方法。</p>\n<p>现在我们编写一个异步加载数据的示例，当组件加载完毕后，异步请求豆瓣的图书API并在页面上显示评分，index.js代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import React from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nvar AjaxGetData= React.createClass({\n  getInitialState(){\n    return {rating: 0}\n  },\n  render(){\n    var rating=this.state.rating;\n    return(\n      &lt;div&gt;书籍：《满月之夜白鲸现》 的豆瓣评分：{rating}分&lt;/div&gt;\n    )\n  },\n  componentDidMount(){\n    var url=&#39;https://api.douban.com/v2/book/6548683&#39;;\n\t $.ajax({\n        type: &quot;GET&quot;,\n        dataType: &#39;jsonp&#39;,\n        url: url\n      }).done(function(json){\n        var rating = json.rating.average;\n        this.setState({rating:rating});\n      }.bind(this));\n\n  }\n})\n\nReactDOM.render(\n  &lt;AjaxGetData /&gt;,\n  document.getElementById(&#39;demo3&#39;)\n)</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p>关于豆瓣图书API文档可查阅<a href=\"https://developers.douban.com/wiki/?title=book_v2#get_isbn_book\">此处</a>。</p>\n</blockquote>\n<blockquote>\n<p>注意，在ajax请求的done方法后面多了一个bind(this)，后面文章会详细讲解此点。</p>\n</blockquote>\n<h3>代码解析</h3>\n<p>在上面代码中可以看到，组件中多了一个componentDidMount方法，该方法在组件加载完毕后会触发，且只会触发一次。与之对应多还有一个事件方法是componentWillMount，表示组件的render方法执行前触发。</p>\n<p>假如我们在这三个方法内加入调试信息比如：console.log(方法名)，则得到这三个方法的执行顺序如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">componentWillMount\nrender\ncomponentDidMount</code>\n        </deckgo-highlight-code>\n      \n<p>前文说过，当组件的state值改变时，组件会刷新，并导致render方法重新执行。但是componentWillMount和componentDidMount只会执行一次，直至被销毁。</p>\n<h3>shouldComponentUpdate方法</h3>\n<p>shouldComponentUpdate是react组件生命周期中的一个重要方法，它觉得着是否需要刷新组件，当它返回true时则刷新组件，返回false，则不必。它默认的判断依据是state是否改变，我们也可以根据自己的需求来修改刷新条件，比如像下面这样，只有当id属性改变时，才刷新组件。</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">shouldComponentUpdate(nextProps, nextState): {\n  return nextState !== this.state.id;\n}</code>\n        </deckgo-highlight-code>\n      \n<p>一旦shouldComponentUpdate返回true，确定更新，render的前后会执行另外一对事件方法，它们是componentWillUpdate和componentDidUpdate。加入调试信息，可看到组件更新导致的这四个方法的触发顺序是：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">shouldComponentUpdate\n componentWillUpdate\n render\n componentDidUpdate</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p> 其他的事件方法，可在<a href=\"https://facebook.github.io/react/docs/component-specs.html\">官网此处</a>查询。</p>\n</blockquote>\n<h3>示例代码</h3>\n<p>本文<a href=\"https://github.com/twomeetings/reactExamples\">示例代码</a>可在在目录demo3中查阅。</p>","frontmatter":{"title":"React系列之三 － 组件的事件","date":"November 08, 2015","description":null}}},"pageContext":{"slug":"/20151108-react-part-3/","previous":{"fields":{"slug":"/20150721-react-part-2/"},"frontmatter":{"title":"React系列之二 － state"}},"next":{"fields":{"slug":"/20160104-react-part-4/"},"frontmatter":{"title":"React系列之四－扩展知识点ref和mixin"}}}},"staticQueryHashes":["2841359383"]}