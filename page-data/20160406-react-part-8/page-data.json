{"componentChunkName":"component---src-templates-blog-post-js","path":"/20160406-react-part-8/","result":{"data":{"site":{"siteMetadata":{"title":"上线前夕"}},"markdownRemark":{"id":"05e1dd78-8b0c-5248-9252-c3cbf34ab31a","excerpt":"在系列文章第三篇中，我们谈到了组件的事件，但只提到了其中两个事件方法，其实react组件的事件方法并不多，总共只有7个，如下： 所有的这些事件拼成了react组件的生命周期，那么，在整个生命周期中，这些事件的顺序是怎样的？本文中，我创建一个示例，通过在每个事件中用console.log…","html":"<p>在<a href=\"/20151108-react-part-3\">系列文章第三篇</a>中，我们谈到了组件的事件，但只提到了其中两个事件方法，其实react组件的事件方法并不多，总共只有7个，如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">componentWillMount\ncomponentDidMount\ncomponentWillReceiveProps\nshouldComponentUpdate\ncomponentWillUpdate\ncomponentDidUpdate\ncomponentWillUnmount</code>\n        </deckgo-highlight-code>\n      \n<p>所有的这些事件拼成了react组件的生命周期，那么，在整个生命周期中，这些事件的顺序是怎样的？本文中，我创建一个示例，通过在每个事件中用console.log输出信息到控制台，来查看执行顺序，代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">componentWillMount(){\n    console.log(&#39;componentWillMount&#39;);\n  }</code>\n        </deckgo-highlight-code>\n      \n<p>然后创建一个类似<a href=\"/20150721-react-part-2\">系列文章第二篇</a>中的组件，可以通过选中下拉框，来改变组件本身的state，这也就可以观察到组件初始化时和状态改变时，两种状态下的生命周期。现在，创建index.js，基本代码如下：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">import React, { Component } from &#39;react&#39;\nimport ReactDOM from &#39;react-dom&#39;\n\nclass SimpleComponent extends Component{\n  constructor() {\n    super()\n    this.state={selectedValue: &#39;&#39; }\n  }\n\n  _handleChange(event){\n    this.setState({selectedValue: event.target.value})\n  }\n\n  render(){\n  \tconsole.log(&#39;render&#39;)\n    return(\n      &lt;div&gt;\n        &lt;select onChange={this._handleChange.bind(this)} &gt;\n          &lt;option value=&#39;&#39;&gt;&lt;/option&gt;\n          &lt;option value=&#39;nodejs&#39;&gt;nodejs&lt;/option&gt;\n          &lt;option value=&#39;react&#39;&gt;react&lt;/option&gt;\n        &lt;/select&gt;\n        &lt;p&gt;selected value is : {this.state.selectedValue}&lt;/p&gt;\n      &lt;/div&gt;\n    )\n  }\n  \n  /.../\n}</code>\n        </deckgo-highlight-code>\n      \n<blockquote>\n<p>这里为了让代码简洁，为省略了只有console.log的7个事件方法，详情可在代码示例中查看。</p>\n</blockquote>\n<p>编译后页面如图所示：\n<code>图片</code></p>\n<p>现在，我们观察浏览器控制台，当页面初始化时，我们得到信息如下，可以看到加上render方法，只有3个事件方法被触发：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">componentWillMount\nrender\ncomponentDidMount</code>\n        </deckgo-highlight-code>\n      \n<p>然后，选中下拉框来修改组件state状态，得到如下信息：</p>\n\n        <deckgo-highlight-code  >\n          <code slot=\"code\">shouldComponentUpdate\ncomponentWillUpdate\nrender\ncomponentDidUpdate</code>\n        </deckgo-highlight-code>\n      \n<h3>复杂组件的生命周期</h3>\n<p>从上文到演示中可以看到单个组件初始化和状态改变时的生命周期，但奇怪的是，7个生命周期事件中，只有5个被触发，另外两个在什么情况下才会触发呢？</p>\n<p>现在我们将组件设计的复杂一些，结合<a href=\"/20160328-react-part-7\">系列文章第七篇</a>中的容器组件和呈现组件的例子，当用户选择了下拉框之后，根据选中内容请求豆瓣图书API获取图书，再将书名呈现出来。在这样的情况下，我们观察一下容器组件和呈现组件的生命周期会是怎样的。</p>\n<p>页面呈现如下：</p>\n<p><img src=\"http://7xtbg7.com2.z0.glb.clouddn.com/React8-1\"></p>\n<p>现在，我们用蓝色表示容器组件的生命周期，绿色组件表示呈现组件的生命周期。初始化时，控制台信息如下：</p>\n<p><img src=\"http://7xtbg7.com2.z0.glb.clouddn.com/React8-2\"></p>\n<p>选择下拉框，改变状态以后，控制台信息如下：</p>\n<p><img src=\"http://7xtbg7.com2.z0.glb.clouddn.com/React8-3\"></p>\n<h3>结语</h3>\n<p>本文代码可在<a href=\"https://github.com/twomeetings/reactExamples\">示例代码</a>中的demo8目录中查询。</p>","frontmatter":{"title":"React系列之八－组件的生命周期","date":"April 06, 2016","description":null}}},"pageContext":{"slug":"/20160406-react-part-8/","previous":{"fields":{"slug":"/20160328-react-part-7/"},"frontmatter":{"title":"React系列之七－组件间的通信－呈现组件和容器组件"}},"next":{"fields":{"slug":"/20160612-redux-part-1/"},"frontmatter":{"title":"Redux系列之一－开篇"}}}},"staticQueryHashes":["2841359383"]}