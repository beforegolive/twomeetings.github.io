<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[上线前夕]]></title><description><![CDATA[A starter blog demonstrating what Gatsby can do.]]></description><link>https://gatsby-starter-blog-demo.netlify.com</link><generator>GatsbyJS</generator><lastBuildDate>Mon, 03 Aug 2020 02:31:22 GMT</lastBuildDate><item><title><![CDATA[Promise.all和Promise.allSettled的区别]]></title><description><![CDATA[不管你是否还学的动，JS语言依然在以自己的节奏飞快的进化。转眼间，Promise的工具包里又多了一个方法Promise.allSettled供你选择，它看起来像是对Promise.all的一种补充，缓解了使用Promise.all碰到reject…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-07-29-the-diff-between-promise-all-and-promise-allsettled/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-07-29-the-diff-between-promise-all-and-promise-allsettled/</guid><pubDate>Wed, 29 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;不管你是否还学的动，JS语言依然在以自己的节奏飞快的进化。转眼间，Promise的工具包里又多了一个方法Promise.allSettled供你选择，它看起来像是对Promise.all的一种补充，缓解了使用Promise.all碰到reject的痛点问题。&lt;/p&gt;
&lt;p&gt;一句话概括Promise.allSettled和Promise.all的最大不同：&lt;strong&gt;Promise.allSettled永远不会被reject&lt;/strong&gt;。&lt;/p&gt;
&lt;h3&gt;解决Promise.all的痛点&lt;/h3&gt;
&lt;p&gt;当需要处理多个Promise并行时，大多数情况下Promise.all用起来是非常顺手的，比如下面这样&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;const delay = n =&amp;gt; new Promise(resolve =&amp;gt; setTimeout(resolve, n));

const promises = [
  delay(100).then(() =&amp;gt; 1),
  delay(200).then(() =&amp;gt; 2),
  ]

Promise.all(promises).then(values=&amp;gt;console.log(values))
// 最终输出： [1, 2]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可是，是一旦有一个promise出现了异常，被reject了，情况就会变的麻烦。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;const promises = [
  delay(100).then(() =&amp;gt; 1),
  delay(200).then(() =&amp;gt; 2),
  Promise.reject(3)
  ]

Promise.all(promises).then(values=&amp;gt;console.log(values))
// 最终输出： Uncaught (in promise) 3

Promise.all(promises)
.then(values=&amp;gt;console.log(values))
.catch(err=&amp;gt;console.log(err))
// 加入catch语句后，最终输出：3&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;尽管能用catch捕获其中的异常，但你会发现其他执行成功的Promise的消息都丢失了，仿佛石沉大海一般。&lt;/p&gt;
&lt;p&gt;要么全部成功，要么全部重来，这是Promise.all本身的强硬逻辑，也是痛点的来源，不能说它错，但这的确给Promise.allSettled留下了立足的空间。&lt;/p&gt;
&lt;p&gt;假如使用Promise.allSettled来处理这段逻辑会怎样呢?&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;const promises = [
  delay(100).then(() =&amp;gt; 1),
  delay(200).then(() =&amp;gt; 2),
  Promise.reject(3)
  ]

Promise.allSettled(promises).then(values=&amp;gt;console.log(values))
// 最终输出： 
//    [
//      {status: &amp;quot;fulfilled&amp;quot;, value: 1},
//      {status: &amp;quot;fulfilled&amp;quot;, value: 2},
//      {status: &amp;quot;rejected&amp;quot;, value: 3},
//    ]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可以看到所有promise的数据都被包含在then语句中，且每个promise的返回值多了一个status字段，表示当前promise的状态，没有任何一个promise的信息被丢失。&lt;/p&gt;
&lt;p&gt;因此，当用Promise.allSettled时，我们只需专注在then语句里，当有promise被异常打断时，我们依然能妥善处理那些已经成功了的promise，不必全部重来。&lt;/p&gt;
&lt;h3&gt;当前大环境对Promise.allSettled的支持&lt;/h3&gt;
&lt;p&gt;nodejs从&lt;a href=&quot;https://nodejs.org/en/blog/release/v12.9.0/&quot;&gt;v12.9.0&lt;/a&gt;开始加入了对Promise.allSettled的支持，主流浏览器们也各自在2019年发布的版本中支持了此方法，这意味着你已经可以放心大胆的使用了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/29/17397a0e39508308?w=2548&amp;#x26;h=634&amp;#x26;f=png&amp;#x26;s=166617&quot;&gt;&lt;/p&gt;
&lt;p&gt;对于那些不支持此方法的环境，你可以直接引用开源社区中实现了此方法的npm包：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/promise.allsettled&quot;&gt;promise.allsettled&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/promise-settle&quot;&gt;promise-settle&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/promise-all-settled&quot;&gt;promise-all-settled&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://www.npmjs.com/package/es2015-promise.allsettled&quot;&gt;es2015-promise.allsettled&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;或者，你可以直接基于Promise.all写一个polyfill，给你的项目打上补丁：&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;if (Promise &amp;amp;&amp;amp; !Promise.allSettled) {
  Promise.allSettled = function (promises) {
    return Promise.all(promises.map(function (promise) {
      return promise.then(function (value) {
        return { state: &amp;#39;fulfilled&amp;#39;, value: value };
      }).catch(function (reason) {
        return { state: &amp;#39;rejected&amp;#39;, reason: reason };
      });
    }));
  };
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;Promise.allSettled是对Promise.all的一种补充，当面对多个promise并行时，它额外提供了一种处理方式，解决了当多个promise并行时reject的出现会伴随着其他promise数据丢失的问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/trabe/using-promise-allsettled-now-e1767d43e480&quot;&gt;using-promise-allsettled-now&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/tc39/proposal-promise-allSettled&quot;&gt;proposal-promise-allSettled&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/robhicks/es2015-Promise.allSettled&quot;&gt;es2015-Promise.allSettled&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://nodejs.org/en/blog/release/v12.9.0/&quot;&gt;nodejs v12.9.0 release notes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[如何搭建类似麦当劳店中需登录认证的wifi]]></title><description><![CDATA[日常生活中常能碰到一些商场或餐饮店提供一种需认证的wifi，这种wifi连接后不能立刻使用，往往还需要在一个页面上进一步认证操作才行，比如输入手机号填个验证码之类的。 作为一名前端开发，每当我去麦当劳店里吃饭，用手机连接wifi时，一直都很想搞清楚几个问题： 这种wifi…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-07-24-how-to-build-captive-portal-with-nodogslash/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-07-24-how-to-build-captive-portal-with-nodogslash/</guid><pubDate>Fri, 24 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;日常生活中常能碰到一些商场或餐饮店提供一种需认证的wifi，这种wifi连接后不能立刻使用，往往还需要在一个页面上进一步认证操作才行，比如输入手机号填个验证码之类的。&lt;/p&gt;
&lt;p&gt;作为一名前端开发，每当我去麦当劳店里吃饭，用手机连接wifi时，一直都很想搞清楚几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;这种wifi认证页面是如何搭建的？&lt;/li&gt;
&lt;li&gt;它的认证机制是怎样的？&lt;/li&gt;
&lt;li&gt;它跟正常的网站会有哪些不一样？&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;我工作地旁边的麦当劳wifi认证截图：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/196de2acca8af0eb2069f570ddb7a229/b2ead/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 216.89189189189187%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAArABQDASIAAhEBAxEB/8QAGQABAAMBAQAAAAAAAAAAAAAAAAMEBQIG/8QAFwEBAQEBAAAAAAAAAAAAAAAAAAECA//aAAwDAQACEAMQAAAB9FFY7z0zWkS1xfVGlXBnk0GcP//EAB8QAAEEAgIDAAAAAAAAAAAAAAIAAQMEERQFEhMgIf/aAAgBAQABBQJ7OFt/S5SIHkrVHfxVeujVkRV4CLWrqMAjH2y6y67Ov//EAB0RAAECBwAAAAAAAAAAAAAAAAABAhAREhMiUWH/2gAIAQMBAT8Bp4Ylx+xVnH//xAAXEQADAQAAAAAAAAAAAAAAAAAAESEg/9oACAECAQE/AaUWP//EACIQAAEDAwMFAAAAAAAAAAAAAAEAAhEDITEgMmEzcXKRov/aAAgBAQAGPwLZc8q9M2UEFEOfB81Bq/andzMol1JpPZdFnpQxoaONeVlZX//EAB0QAQEBAQACAwEAAAAAAAAAAAERACExYRAgQXH/2gAIAQEAAT8hsI/AcZQyX9ZfZ/mHFTpzHVBECV7wGSTmTVK1Xy+M9RjYNDQ+vub3N7W//9oADAMBAAIAAwAAABBgw8Hf/wD/xAAaEQEAAwADAAAAAAAAAAAAAAABABEhQZGh/9oACAEDAQE/ENcvY0xGBFD7Yitdly5//8QAGhEAAgIDAAAAAAAAAAAAAAAAABEBEFFhcf/aAAgBAgEBPxCNjsTFIR//xAAfEAEAAgEEAwEAAAAAAAAAAAABABEhMUFRYSBx8YH/2gAIAQEAAT8Qy4sjUr0OvqLaXGwW9vyb1FQWPdxN8DmQbGrw98RwaQNR23mERYEbW155lbGzVXcXq2rrL+4sIW6sWbQudUANPD7s+5Cx5+Z//9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal    1&quot;
        title=&quot;captive portal    1&quot;
        src=&quot;/static/196de2acca8af0eb2069f570ddb7a229/625aa/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg&quot;
        srcset=&quot;/static/196de2acca8af0eb2069f570ddb7a229/c4d45/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg 148w,
/static/196de2acca8af0eb2069f570ddb7a229/1f0d7/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg 295w,
/static/196de2acca8af0eb2069f570ddb7a229/625aa/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg 590w,
/static/196de2acca8af0eb2069f570ddb7a229/f8367/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg 885w,
/static/196de2acca8af0eb2069f570ddb7a229/b2ead/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B31.jpg 1080w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/74709bc59e4f1d9e8a298d857c3843e7/b2ead/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 216.89189189189187%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAArABQDASIAAhEBAxEB/8QAGwAAAgIDAQAAAAAAAAAAAAAAAAYCAwEEBwX/xAAVAQEBAAAAAAAAAAAAAAAAAAAAAf/aAAwDAQACEAMQAAABaY84pOpiKGpr4pPcIBfU9AqDWJ//xAAfEAABBAICAwAAAAAAAAAAAAADAAECBBEzBRQTFSP/2gAIAQEAAQUC7AGfsAUTCdF3KpqIL6uN8VIT8ZdyqaicXZefq7SrUbUIZWVl1//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8BX//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8BX//EACcQAAECAwcEAwAAAAAAAAAAAAEAAgMRchAhIjEyUYEEEjNCcZHR/9oACAEBAAY/AvPDB+Vf1ML7WGNDPKfUbDUnz7tRyl+rCDzJHD7bp9RsNScQ3NxWhEOhSv3Fua//xAAiEAABAwMEAwEAAAAAAAAAAAABABEhQVHwMWGBkRBxscH/2gAIAQEAAT8hJQEbEigcyeKBkhHouev4ytgprU7Eo3OzVwfqFfDgsEOdVMsrYLU+gSL+1EYQWZxJ7T5l8wTr1dOvV0BPJf/aAAwDAQACAAMAAAAQgA8MEP8A/8QAFxEAAwEAAAAAAAAAAAAAAAAAAAERIP/aAAgBAwEBPxDFRT//xAAXEQADAQAAAAAAAAAAAAAAAAAAAREg/9oACAECAQE/EMRkP//EACMQAQACAgIBAwUAAAAAAAAAAAEAESExUXFhQZGhEIHB0fD/2gAIAQEAAT8QYXii8PVy0UGsX33MHGFJp95lbn9v6fNSsIyLkp8wh0wGgRzVOB5G3qfNA0nT5ynB7Qmk2kV1AHIkL7QdcgAJg1w4zGsW2rsUej4Ycr8nPc/kb57iVAttp3P/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal    2&quot;
        title=&quot;captive portal    2&quot;
        src=&quot;/static/74709bc59e4f1d9e8a298d857c3843e7/625aa/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg&quot;
        srcset=&quot;/static/74709bc59e4f1d9e8a298d857c3843e7/c4d45/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg 148w,
/static/74709bc59e4f1d9e8a298d857c3843e7/1f0d7/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg 295w,
/static/74709bc59e4f1d9e8a298d857c3843e7/625aa/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg 590w,
/static/74709bc59e4f1d9e8a298d857c3843e7/f8367/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg 885w,
/static/74709bc59e4f1d9e8a298d857c3843e7/b2ead/captive-portal-%E9%BA%A6%E5%BD%93%E5%8A%B32.jpg 1080w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;这种wifi的英文学名叫&lt;strong&gt;Captive Portal&lt;/strong&gt;，在开源社区中早已存在一些组件可轻松搭建这种类型的wifi，比如wifiDog, CoovaChilli, nodogslash等。&lt;/p&gt;
&lt;p&gt;为了一探究竟，我用nodogslash在树莓派上搭建了一个带认证功能的wifi，并且使用React创建了自定义认证页面，尝试搞清楚整个认证流程背后的原理。&lt;/p&gt;
&lt;p&gt;最终认证页面效果如下，点击按钮即完成认证：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1adbbd735d5e26ef37da814bfd694e71/c87b7/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 89.1891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACQklEQVQ4y42Ui46aQBSGff8n6SP0ETabbdKkNd5iVRRcUOSODAzz9z+zQMCu2Z7kOAMcv3OdmYFijPlSezvdNFzb7rmF1tS2HWxmTwEG/wDjJIGz28FzXTjHI3bcH5wTDtznefYBxBPpGENkIkVRILrdkN5C+J6HwPcRRxEul4v9NkR4o1HED/f7HY7jII5jqKpCEAeo63oCLbnsG4OSe0XVndOGpRiAWZYhSVOkXLfbLcIwRJIVcPwbaqWsYWuBBif+71vSYKEM1rVB2H6k0zu2wEbTj2ir0TAyQ29No5EW1eC5j8I6ZnplniPlvqJ9y6ZMgCJHpfG7bBBrg4RqMeziGCiAH29vWC2X2Gw2WK/XtjECHVJuO+DPSuN7prCvNbbUQrrLqMdAKfyRHT2fz1Z9NkV0ArSFLu9IowQqr1GmCmlcsSma8zUF5kxzPp9jtVrZ6GSVBooMKcuP5yZ4fT2xITG2f2IaR4wks7AxsCxLm6pEJ42TcUk4m2bcFAv0Cry8BATFWC4jLBYR3t9LGjXslcb4NPXNkVHrIZOmyE8U5YwoZNELpsARSnIaKAvrIxyfGnmvlJo4mwCDwGdtfjG6Bfb7Ha7Xqx1y8fwZcHqiDO0egPIgHRRVqrYHvo/kEfhMJidlPGcuD76MgYh+GBsZdkXntdVm0Irpq+5Ezfr8ReWlwGSV5/F82VrHCfa8XZyTxxvGxeHEW8c9Y3c4IuNIDcA+ElntxdAVXHScgdS0fy91Ftu+zsN9iP+Qr+o3tvsLA695FOBwnUcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal    wifi   &quot;
        title=&quot;captive portal    wifi   &quot;
        src=&quot;/static/1adbbd735d5e26ef37da814bfd694e71/102e5/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png&quot;
        srcset=&quot;/static/1adbbd735d5e26ef37da814bfd694e71/83276/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 148w,
/static/1adbbd735d5e26ef37da814bfd694e71/ba02f/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 295w,
/static/1adbbd735d5e26ef37da814bfd694e71/102e5/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 590w,
/static/1adbbd735d5e26ef37da814bfd694e71/74549/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 885w,
/static/1adbbd735d5e26ef37da814bfd694e71/7213b/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 1180w,
/static/1adbbd735d5e26ef37da814bfd694e71/c87b7/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 1240w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;wifi认证的机制和原理&lt;/h3&gt;
&lt;p&gt;每当设备连接wifi后，系统会自动做一个连通性校验，此校验的本质是发送一个HTTP请求。如果请求失败，则会触发相应机制要求用户输入登录凭证。如果请求成功，则表示网络已通，无任何回应，这个网络校验过程叫Captive Portal Detection (CPD)。&lt;/p&gt;
&lt;p&gt;不同的操作系统校验时的请求地址不一样，比如我用手边的android和iphone手机分别做了测试，他们对应校验地址如下：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;http://connectivitycheck.smartisan.com/wifi.html&quot;&gt;http://connectivitycheck.smartisan.com/wifi.html&lt;/a&gt; （坚果 pro3）&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://captive.apple.com/hotspot-detect.html&quot;&gt;http://captive.apple.com/hotspot-detect.html&lt;/a&gt; （iphone 6）&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;简单来说，wifi的认证过程通过一个HTTP GET请求即可完成。以我本文示例中使用的&lt;code&gt;nodogsplash&lt;/code&gt;组件为例，其内部用C语言实现了一个服务器运行在2050端口。设备连上wifi时，wifi端会生成一个token，当设备被重定向到认证页面时，页面模板中包含此token，此时用户只需发送一个GET请求将此token传入到对应服务器的认证地址即可。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/827e187729b3e939b180723a0ef10e91/3933f/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 36.486486486486484%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAAA8klEQVQoz32RX0vDMBTF9/0/jPgke/JNHBsyxMH0wSrVdXFdgm1v2qRNckxjDZ37cyCEnFx+Obl3Ai/nHP6r98b27/l03ViTP6PfddtBqRbG2FjQqgJE1RHYWjfUuYPHIrDtDHJegmoF8U2wg1/wBEmSgDEGznkEv7ztsVxvj9JHoGw0tjsBWTfIvsSQwmLPXpGmaVhEBOM9YwxYXiAX1Xng+8cO19MZrm5muL17ROO/HhKKFJvNJ7Isg5QSRSlxv3jC/GGF+fLZB9AHvYzAPo2N/bGhR706TSEZeZjWOtyTbFBWtYcpjGcQgOemfMm/VPcDtVoiAGitl6cAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal     &quot;
        title=&quot;captive portal     &quot;
        src=&quot;/static/827e187729b3e939b180723a0ef10e91/102e5/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png&quot;
        srcset=&quot;/static/827e187729b3e939b180723a0ef10e91/83276/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png 148w,
/static/827e187729b3e939b180723a0ef10e91/ba02f/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png 295w,
/static/827e187729b3e939b180723a0ef10e91/102e5/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png 590w,
/static/827e187729b3e939b180723a0ef10e91/74549/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png 885w,
/static/827e187729b3e939b180723a0ef10e91/7213b/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png 1180w,
/static/827e187729b3e939b180723a0ef10e91/3933f/captive-portal-%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86.png 1636w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;如果你配置了FAS，也就是说设置了自定义认证机制，比如说你想添加了一个手机验证环节，需要用户填入手机和验证码才能完成认证。那么&lt;code&gt;nodogsplash&lt;/code&gt;在重定向登录页面的时候会把一些重要参数附带在请求地址的后面，让你的自定义入口页能获取到这些认证凭证，比如token之类的参数。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/471847de99f63a6683f91b6d1ebd031e/46db9/captive-portal-%E8%AE%A4%E8%AF%81%E9%A1%B5%E9%9D%A2-highlight.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 206.75675675675674%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAApCAYAAAA1bQl+AAAACXBIWXMAABYlAAAWJQFJUiTwAAAEEElEQVRIx+VWyY7rVBDNP7NnyxoJFmxYwg8ggcQTPLpf03mdefJsZ3ASp5PO6CTteDpUXScdx+mEBvUGcaWjuuO5VXVdVc45joMsRqMR+v0+KpUKms0mVFWFoiioVqsCw+FQ7Dns53G32xUyZ5omXoOu6yiVSqjVari/v0c+n38hNAzjZZ9lWdA0DcViCQadyc1mM1zCcrnEYrHAdDoV4DHj0t6npyfk8I4tCkPk4jhGGsARPI72iP8G3Hx/dyTkxnIaRHgizAgnt8fHCw7toMDhfOD7icmHiWkQ44e5j2+ePPxIkjc7foR5eE6+SylxQphMiBXkNz6+Gnv4wtnh64mH6jbA9zMf3009/LLy8bvr46eljz9IfnCDE80zhMmE5oVEtMOXIw/fkpaPpF3lORJEH9yE6GciLtJFzefwdQ1ZsziKhIY7koVNgI90sETaIvNIL4gTCKI4OvfhtfYaJS7MJSaPHYRqA4EhIzIVRJaGQEgV4WFuP2YEuoSQxmhrQM8E9Bbi2eT42QRSFfXffsXD7Q2aD3lMuh3IpQLarQakYgF6rYrG57zo26qC4s1HlD/dYN634bkr7OgSQc6EOyL0tRbqhQc0KQFoFKMKxaOkqLAHQ/SHDmwK+E7PhtFuw3kcY0BJQaa9fZq3aE+vWQf67RQhmcsatGQFdq+HRqMBk4hnHLsUxxzLi/kca9fFZr3GdrsVeCa422e4vQ5gW0fCkHzQIg0r9TparZZIU5xpOMtwZikWi7j7dIdCoSAu43G5XKF+HVVObZ//JA07R8LIkIRPynS4QaRMVGdy2twkAkZ1nxf5Il3XoMgy7a2hQbJdLiLupTQMlDp0Wlx7O6zILHezwWK1wpL6KzJxTaZxf7lyxTyvrzc0R/0VndkObcRd40jI7F75HjGZDlNOYMipvkSvSC9pKQl4zHtZ8rhBGo4GyXcoNKToqJbLuLu9hTMYQCLTDlCkFtqUlTVFhkFZuU5uUcnMjmXSYY8CORJRdvJh74hV1AvyHUv2VYUOsh/r5D/btkVt0YT/dPRozJIzdDrtvRAGQSBel1+QwYQyaSFJkpBMxn1e49rBki/jejOnz+mMMKS0zYu8kQlYcuHhqsZVjDVk2aNvlMF9roidTgds3RlhRD4YkO/G4zEmk4nAil7wn7RjCUjlQyY+gLXm23kDg/vpcRZnhEyQRdbhIjunLk3jhPCS+uwrDjOOHH4oluy7N5ucLYkbiggu4JwcDsV8TZFzrYxezNhpM9+ydpUwzpTH1zTJEl/14b9p/2PC4L9BGL/h3y9+4/9hELy3hpRb31dDNnngPKJPYDkY7WW2fw2j5HyP/iIGzgg51epC0kyoZgca9WXNgmK0RV81CdYV7M/w+WKN6na7i78AF2w/a3+HlhMAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal      highlight&quot;
        title=&quot;captive portal      highlight&quot;
        src=&quot;/static/471847de99f63a6683f91b6d1ebd031e/102e5/captive-portal-%E8%AE%A4%E8%AF%81%E9%A1%B5%E9%9D%A2-highlight.png&quot;
        srcset=&quot;/static/471847de99f63a6683f91b6d1ebd031e/83276/captive-portal-%E8%AE%A4%E8%AF%81%E9%A1%B5%E9%9D%A2-highlight.png 148w,
/static/471847de99f63a6683f91b6d1ebd031e/ba02f/captive-portal-%E8%AE%A4%E8%AF%81%E9%A1%B5%E9%9D%A2-highlight.png 295w,
/static/471847de99f63a6683f91b6d1ebd031e/102e5/captive-portal-%E8%AE%A4%E8%AF%81%E9%A1%B5%E9%9D%A2-highlight.png 590w,
/static/471847de99f63a6683f91b6d1ebd031e/46db9/captive-portal-%E8%AE%A4%E8%AF%81%E9%A1%B5%E9%9D%A2-highlight.png 706w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;等你的自定义验证手机验证通过了，再选择将token以HTTP GET请求发送回原2050端口上的认证服务器，整个流程如下图所示：&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/47c0b74ae04b51fc378d6f4efb6ab746/1cf17/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 60.810810810810814%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAABYlAAAWJQFJUiTwAAABVElEQVQoz5VTa0/CMBTdPzcm/iAD6Hf9Aj6+KahBcENeyza20W7rY92xFJiDOQw3uWlz055zbs+thTOiKIpynzEGpYpa3Tp1cbMe5yZsZ4LrVgePT88H5xoBj1mroZRCt/eAi8srtNo3Ze0kYKlQCQjOwIWAlHJ3UaHff0O7c4sgCM4DzAVBHPrw/UCnD855o/J921bTm8GsGjRXOvMaWZYlSNaeIdsrPVD4F7MwreZ1MvMcUiczqoXgv4DVQxkTCGOKKE5KIBQ5cilqCpc+QRClp1tek0wbIDWrBEmyLQmZw7GHWK1CUEqxb2Qw8rDwyNaU6hxWFb5/TnHXfcF97xXThW9qabJGHIUacIUoijRpiuFogsHHGM7UrQ23VTXE9UJ8TVzY365ufcsuONWAG7AYTP+OjHGMnTnG9gyzZXBgaGlK0yiY0ZEpKIlBCDUG/PcJfgDkzamY8Qbt5AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal FAS    &quot;
        title=&quot;captive portal FAS    &quot;
        src=&quot;/static/47c0b74ae04b51fc378d6f4efb6ab746/102e5/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png&quot;
        srcset=&quot;/static/47c0b74ae04b51fc378d6f4efb6ab746/83276/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png 148w,
/static/47c0b74ae04b51fc378d6f4efb6ab746/ba02f/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png 295w,
/static/47c0b74ae04b51fc378d6f4efb6ab746/102e5/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png 590w,
/static/47c0b74ae04b51fc378d6f4efb6ab746/74549/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png 885w,
/static/47c0b74ae04b51fc378d6f4efb6ab746/7213b/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png 1180w,
/static/47c0b74ae04b51fc378d6f4efb6ab746/1cf17/captive-portal-FAS%E5%90%8E%E7%9A%84%E5%8E%9F%E7%90%86.png 1762w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;认证站点的限制&lt;/h4&gt;
&lt;p&gt;需要注意的是，当用户设备连上wifi但还尚未通过验证时，网络访问是受限的，此时能访问的内容取决于防火墙的设置。比如我上面示例中，将站点配置在路由器上，网站端口是8080，依赖的后端服务器运行在端口8081上，此时必须在&lt;code&gt;nodogsplash&lt;/code&gt;的防火墙规则中开放这两个端口，才能让未认证的用户设备访问的到。假如服务器配置在外网，就要将对应的域名或IP在防火墙中开放出来，具体配置方式参考&lt;code&gt;nodogsplash&lt;/code&gt;关于&lt;a href=&quot;https://nodogsplash.readthedocs.io/en/v4.5.1/fas.html&quot;&gt;FAS的文档&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;另外，wifi认证页面的实现上要有一些额外的安全考量。比如在&lt;code&gt;nodogsplash&lt;/code&gt;的官网文档中建议网站遵循一下安全准则：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当认证成功后需立刻关闭浏览器&lt;/li&gt;
&lt;li&gt;禁止使用链接&lt;/li&gt;
&lt;li&gt;禁止文件下载功能&lt;/li&gt;
&lt;li&gt;禁止执行javascript&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;关于第二条，可以使用表单提交的方式替换链接调整，而对于第四条，它的本意并不是禁止js功能，只是为了防止执行js语句引起的安全性问题。我在示例中搭建的网站使用了react框架，在android和ios上都能正常显示。&lt;/p&gt;
&lt;p&gt;因此，在功能实现上相比较通常的前端站点，自定义的wifi认证网站部分功能受限，但影响并不大，可以使用你自己擅长的前端框架来搭建。&lt;/p&gt;
&lt;h3&gt;创建需认证的wifi&lt;/h3&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;注意，如果你手边没有树莓派或Linux系统，或者对配置部分不感兴趣，直接跳过即可。&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;准备工作&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;树莓派 4B&lt;/li&gt;
&lt;li&gt;hostapd和dnsmasq (用于创建wifi热点)&lt;/li&gt;
&lt;li&gt;nodogsplash (核心组件，管理wifi热点，提供认证功能)&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;nodogsplash可以安装OpenWrt和Linux中，前者是开源的智能路由器操作系统，国内的一些路由器厂商通常是基于此系统定制的，后者就不必多介绍了，这次的示例就是安装在Linux系统上，为了方便安装调试，我直接使用一个树莓派4作为载体，用网线连通网络，用无线创建热点wifi。&lt;/p&gt;
&lt;h4&gt;创建wifi热点&lt;/h4&gt;
&lt;p&gt;在安装组件之前，首先将依赖包更新，然后安装&lt;code&gt;hostapd&lt;/code&gt;和&lt;code&gt;dnsmasq&lt;/code&gt;两个组件，前者用来创建wifi热点，后者用来处理DNS和DHCP等服务。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo apt-get update
sudo apt-get upgrade

sudo apt-get install hostapd dnsmasq&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;修改配置并指定一个wifi网段，配置文件在&lt;code&gt;/etc/dhcpcd.conf&lt;/code&gt;&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/dhcpcd.conf

# ...

# 文件内容如下：
interface wlan0
    static ip_address=192.168.220.1/24
    nohook wpa_supplicant&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;其中wlan0是无线网卡的名称，可以通过&lt;code&gt;ifconfig&lt;/code&gt;命令查询，IP地址可任意指定，只要不跟家中的wifi冲突即可，比如说此处设置的是192.168.220.*，而我家中的wifi网段是192.168.31.*。&lt;/p&gt;
&lt;p&gt;重启一下服务，让配置生效：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo systemctl restart dhcpcd&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;修改hostapd配置，用于设置wifi的名称和密码，其中ssid表示此wifi的名称，wpa_passphrase表示此wifi的密码。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/hostapd/hostapd.conf

# ...

# 文件内容如下：
interface=wlan0
driver=nl80211

hw_mode=g
channel=6
ieee80211n=1
wmm_enabled=0
macaddr_acl=0
ignore_broadcast_ssid=0

auth_algs=1
wpa=2
wpa_key_mgmt=WPA-PSK
wpa_pairwise=TKIP
rsn_pairwise=CCMP

# wif的名称
ssid=Pi4-AP
# wifi的秘密
wpa_passphrase=pimylifeup&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h5&gt;修改配置文件&lt;code&gt;/etc/default/hostapd&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;这时还需要再修改两个配置文件，一个是&lt;code&gt;hostapd&lt;/code&gt;启动时的加载文件，需要将配置文件字段&lt;code&gt;DAEMON_CONF&lt;/code&gt;指定为上面的文件地址，默认情况下该字段是被注释掉的。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo nano /etc/default/hostapd

# ...
# 文件内容如下：
# 将#DAEMON_CONF=&amp;quot;&amp;quot; 修改为下面这行
DAEMON_CONF=&amp;quot;/etc/hostapd/hostapd.conf&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h5&gt;修改配置文件&lt;code&gt;/etc/init.d/hostapd&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;另一个配置文件是系统服务配置，同意将上文的配置文件地址赋值给&lt;code&gt;DAEMON_CONF&lt;/code&gt;字段。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/init.d/hostapd

# ...

# 文件内容如下：
# 将DAEMON_CONF=修改为下面这行
DAEMON_CONF=/etc/hostapd/hostapd.conf&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h5&gt;修改配置文件&lt;code&gt;/etc/dnsmasq.conf&lt;/code&gt;&lt;/h5&gt;
&lt;p&gt;在此文件配置自定义wifi的网段、dns服务器等信息。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/dnsmasq.conf

# ...

# 文件内容如下：
interface=wlan0       # 指定无线网卡名称 
server=114.114.114.114       # 使用dns服务器
dhcp-range=192.168.220.50,192.168.220.150,12h  # 指定可用IP的网段范围和释放时间&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h5&gt;无线网卡转发有线网卡&lt;/h5&gt;
&lt;p&gt;修改系统配置文件中的&lt;code&gt;net.ipv4.ip_forward&lt;/code&gt;字段，激活转发功能，默认情况下，该字段是被注释掉的。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/sysctl.conf

# ...

# 文件内容如下：
# 将原#net.ipv4.ip_forward=1的注释符号去掉，修改为下面这行
net.ipv4.ip_forward=1&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;重启系统，让此修改生效。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo reboot&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后，通过&lt;code&gt;iptables&lt;/code&gt;命令实现网卡之间的信息转发，其中&lt;code&gt;eth0&lt;/code&gt;是有线网卡的名称，可通过&lt;code&gt;ifconfig&lt;/code&gt;命令查询。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;最后，需要将当前&lt;code&gt;iptables&lt;/code&gt;的配置保存下来，保证每次机器重启时该配置都能生效，先将配置保存到文件中&lt;code&gt;/etc/iptables.ipv4.nat&lt;/code&gt;。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;# 将配置写入/etc/iptables.ipv4.nat文件
sudo sh -c &amp;quot;iptables-save &amp;gt; /etc/iptables.ipv4.nat&amp;quot;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;修改&lt;code&gt;rc.local&lt;/code&gt;，保证每次启动时都会读取&lt;code&gt;iptables&lt;/code&gt;配置。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/rc.local

# ...
# 文件内容如下：

# ...
# 在“exit 0”这一行之前添加下面命令读取iptables的配置
iptables-restore &amp;lt; /etc/iptables.ipv4.nat

exit 0&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h5&gt;启动wifi热点&lt;/h5&gt;
&lt;p&gt;最后，关于热点的配置终于配置完毕，运行一下命令启动服务：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo systemctl unmask hostapd
sudo systemctl enable hostapd
sudo systemctl start hostapd
sudo service dnsmasq start&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这时，应该可以用手机检测到配置的wifi出现了&lt;code&gt;Pi4-AP&lt;/code&gt;，该名称即上面配置的wifi名称，输入对应密码即可连上网络。此时可重启一下再连，确保重启后配置依然生效。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo reboot&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;安装nodogsplash&lt;/h4&gt;
&lt;p&gt;首先安装对应依赖&lt;code&gt;git&lt;/code&gt;和&lt;code&gt;libmicrohttpd-dev&lt;/code&gt;。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo apt install git libmicrohttpd-dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后使用git直接将nodogsplash源码拿下来，直接安装。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;git clone https://github.com/nodogsplash/nodogsplash.git
cd ./nodogsplash
make
sudo make install&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;添加nodogsplash配置&lt;/h4&gt;
&lt;p&gt;添加配置到文件&lt;code&gt;/etc/nodogsplash/nodogsplash.conf&lt;/code&gt;中，指定对应网卡、网关、最大连接用户数和认证过期时间。其中，&lt;code&gt;wlan0&lt;/code&gt;是上面配置的无线网卡名，IP地址是上面配置的wifi热点的网关。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/nodogsplash/nodogsplash.conf

# ...

# 文件内容如下：
GatewayInterface wlan0
GatewayAddress 192.168.220.1
MaxClients 250
AuthIdleTimeout 480&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;配置完成后，启动nodogsplash。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo nodogsplash&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;此时，用手机连接创建的wifi并输入密码以后，即可看到以下弹窗，要求登录认证。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1762d04da53b6e8797de2aeb27e49c72/b2ead/captive-portal-wifi-popup.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 216.89189189189187%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAArABQDASIAAhEBAxEB/8QAGgABAAIDAQAAAAAAAAAAAAAAAAECAwQGBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdAsQDtNrkMpZ54wWrYgH//EABsQAAMAAgMAAAAAAAAAAAAAAAIDBAAgBRQV/9oACAEBAAEFAtp0rKXrKzkhEKRueAehTjWm89v/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AV//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AV//xAAiEAABAwMDBQAAAAAAAAAAAAABAAIRAxIgISIxMjNBkZL/2gAIAQEABj8CypTSE28wu2PQQDWhu3wmta4QONF1j5V1Qyc//8QAHhAAAwACAQUAAAAAAAAAAAAAAAERECExUYGRsfH/2gAIAQEAAT8hp3KauXwwyNx2KnuBJIlxJ1FZa5SlefCJiRmlCz7hi5wz/9oADAMBAAIAAwAAABDjCgyAD//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQMBAT8QX//EABQRAQAAAAAAAAAAAAAAAAAAACD/2gAIAQIBAT8QX//EACEQAQACAQQBBQAAAAAAAAAAAAEAESExQVFxEGGBkaHR/9oACAEBAAE/EDJxXrC7tDxtUbuYYclyzk+Y6wKuZVSbqZlc3A6ZX1HwlRBd8IGUQIQNM1mVO1AoEEoii9judHvTxqiWu1fnjVP/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal wifi popup&quot;
        title=&quot;captive portal wifi popup&quot;
        src=&quot;/static/1762d04da53b6e8797de2aeb27e49c72/625aa/captive-portal-wifi-popup.jpg&quot;
        srcset=&quot;/static/1762d04da53b6e8797de2aeb27e49c72/c4d45/captive-portal-wifi-popup.jpg 148w,
/static/1762d04da53b6e8797de2aeb27e49c72/1f0d7/captive-portal-wifi-popup.jpg 295w,
/static/1762d04da53b6e8797de2aeb27e49c72/625aa/captive-portal-wifi-popup.jpg 590w,
/static/1762d04da53b6e8797de2aeb27e49c72/f8367/captive-portal-wifi-popup.jpg 885w,
/static/1762d04da53b6e8797de2aeb27e49c72/b2ead/captive-portal-wifi-popup.jpg 1080w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;点击登录后进入认证页面。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/aa330c0c7a21d2ceb6c45007149a43a8/b2ead/captive-portal-splash-page.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 216.89189189189187%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDAAgGBgcGBQgHBwcJCQgKDBQNDAsLDBkSEw8UHRofHh0aHBwgJC4nICIsIxwcKDcpLDAxNDQ0Hyc5PTgyPC4zNDL/2wBDAQkJCQwLDBgNDRgyIRwhMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjIyMjL/wgARCAArABQDASIAAhEBAxEB/8QAGgAAAgMBAQAAAAAAAAAAAAAAAAMBAgQGBf/EABUBAQEAAAAAAAAAAAAAAAAAAAEA/9oADAMBAAIQAxAAAAHp9Hi9EyCAk7soElBajJhQwr//xAAdEAACAgIDAQAAAAAAAAAAAAABAgADERIEIDIi/9oACAEBAAEFAjegYbGElZZxCxX5Wz0lubcR/W5m5hOe/wD/xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAEDAQE/AV//xAAUEQEAAAAAAAAAAAAAAAAAAAAg/9oACAECAQE/AV//xAAjEAABAgMJAQAAAAAAAAAAAAABAAIDEBMSIzAxMkFRcqLB/9oACAEBAAY/AiC5oPYLSZRbNIGJuWoDgSp3nxZ+sP8A/8QAIBABAAICAQQDAAAAAAAAAAAAAQARITFBIFFxgZGh0f/aAAgBAQABPyEcN3eL7mE2HGv2I0hEYpZctVHp8Bsjv1g4dg24+c8kY+ne4AVxPBHdvX//2gAMAwEAAgADAAAAELMJ/O8//8QAGBEBAAMBAAAAAAAAAAAAAAAAAQAQETH/2gAIAQMBAT8QRO0CdrZs/8QAGREAAgMBAAAAAAAAAAAAAAAAABEBEEFR/9oACAECAQE/EHHKh7SEf//EACMQAAICAQQABwAAAAAAAAAAAAERACExQVFhkSBxgbHB0eH/2gAIAQEAAT8QrwIAp8wLj1EaMayAS9ahZgm4nlJ0QBEpabqAtViNIAbxERs1ftDdAijAAayi/s+oKA3u+SAokIFicfWUfaVBeB8DqPgdQGzjO0//2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal splash page&quot;
        title=&quot;captive portal splash page&quot;
        src=&quot;/static/aa330c0c7a21d2ceb6c45007149a43a8/625aa/captive-portal-splash-page.jpg&quot;
        srcset=&quot;/static/aa330c0c7a21d2ceb6c45007149a43a8/c4d45/captive-portal-splash-page.jpg 148w,
/static/aa330c0c7a21d2ceb6c45007149a43a8/1f0d7/captive-portal-splash-page.jpg 295w,
/static/aa330c0c7a21d2ceb6c45007149a43a8/625aa/captive-portal-splash-page.jpg 590w,
/static/aa330c0c7a21d2ceb6c45007149a43a8/f8367/captive-portal-splash-page.jpg 885w,
/static/aa330c0c7a21d2ceb6c45007149a43a8/b2ead/captive-portal-splash-page.jpg 1080w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;&lt;a href=&quot;#section-2&quot;&gt;配置自定义wifi认证页面&lt;/a&gt;&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;nodogsplash&lt;/code&gt;本身提供了自定义验证机制 - &lt;a href=&quot;https://nodogsplash.readthedocs.io/en/v4.5.1/fas.html&quot;&gt;Forwarding Authentication Service (FAS)&lt;/a&gt;，它可以指定自定义的认证页面和认证方式，通过简单配置对应服务器的IP和端口即可。&lt;/p&gt;
&lt;p&gt;比如，我在同一台机器上开启一个react站点，端口为8080，若想把此站点设置为认证入口页，只需在配置文件中添加下面四行代码即可，其中&lt;code&gt;fas_secure_enabled&lt;/code&gt;有&lt;a href=&quot;https://nodogsplash.readthedocs.io/en/v4.5.1/fas.html#example-fas-query-strings&quot;&gt;从0到3的多个等级值&lt;/a&gt;，从低到高会让安全性和复杂性递增，此处选了最简单等级用于做演示。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;sudo vi /etc/nodogsplash/nodogsplash.conf

# ...

# 要添加的内容如下
fasport 8080
fasremoteip 192.168.220.1
faspath /
fas_secure_enabled 0&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;最后，呈现的样子如下，点击按钮即完成认证，顺利联网。&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto;  max-width: 590px;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1adbbd735d5e26ef37da814bfd694e71/c87b7/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 89.1891891891892%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAASCAYAAABb0P4QAAAACXBIWXMAABYlAAAWJQFJUiTwAAACQklEQVQ4y42Ui46aQBSGff8n6SP0ETabbdKkNd5iVRRcUOSODAzz9z+zQMCu2Z7kOAMcv3OdmYFijPlSezvdNFzb7rmF1tS2HWxmTwEG/wDjJIGz28FzXTjHI3bcH5wTDtznefYBxBPpGENkIkVRILrdkN5C+J6HwPcRRxEul4v9NkR4o1HED/f7HY7jII5jqKpCEAeo63oCLbnsG4OSe0XVndOGpRiAWZYhSVOkXLfbLcIwRJIVcPwbaqWsYWuBBif+71vSYKEM1rVB2H6k0zu2wEbTj2ir0TAyQ29No5EW1eC5j8I6ZnplniPlvqJ9y6ZMgCJHpfG7bBBrg4RqMeziGCiAH29vWC2X2Gw2WK/XtjECHVJuO+DPSuN7prCvNbbUQrrLqMdAKfyRHT2fz1Z9NkV0ArSFLu9IowQqr1GmCmlcsSma8zUF5kxzPp9jtVrZ6GSVBooMKcuP5yZ4fT2xITG2f2IaR4wks7AxsCxLm6pEJ42TcUk4m2bcFAv0Cry8BATFWC4jLBYR3t9LGjXslcb4NPXNkVHrIZOmyE8U5YwoZNELpsARSnIaKAvrIxyfGnmvlJo4mwCDwGdtfjG6Bfb7Ha7Xqx1y8fwZcHqiDO0egPIgHRRVqrYHvo/kEfhMJidlPGcuD76MgYh+GBsZdkXntdVm0Irpq+5Ezfr8ReWlwGSV5/F82VrHCfa8XZyTxxvGxeHEW8c9Y3c4IuNIDcA+ElntxdAVXHScgdS0fy91Ftu+zsN9iP+Qr+o3tvsLA695FOBwnUcAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;captive portal    wifi   &quot;
        title=&quot;captive portal    wifi   &quot;
        src=&quot;/static/1adbbd735d5e26ef37da814bfd694e71/102e5/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png&quot;
        srcset=&quot;/static/1adbbd735d5e26ef37da814bfd694e71/83276/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 148w,
/static/1adbbd735d5e26ef37da814bfd694e71/ba02f/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 295w,
/static/1adbbd735d5e26ef37da814bfd694e71/102e5/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 590w,
/static/1adbbd735d5e26ef37da814bfd694e71/74549/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 885w,
/static/1adbbd735d5e26ef37da814bfd694e71/7213b/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 1180w,
/static/1adbbd735d5e26ef37da814bfd694e71/c87b7/captive-portal-%E8%87%AA%E5%AE%9A%E4%B9%89wifi%E5%85%A5%E5%8F%A3%E9%A1%B5.png 1240w&quot;
        sizes=&quot;(max-width: 590px) 100vw, 590px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;备注：关于nodogsplash的版本&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;nodogsplash源码中的master分支指向的3.3.5版本，而此时最新版是5.0.0（笔者写此文章时间2020.7），越新的版本其文档越完善，但要注意的是4.5.1版本是一个分水岭，因为从4.5.1之后该项目的自定义登录授权功能被剥离到一个独立项目&lt;a href=&quot;https://github.com/openNDS/openNDS&quot;&gt;openNDS&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;假如切换到v4.5.1版后碰到&lt;code&gt;libmicrohttpd&lt;/code&gt;报&lt;a href=&quot;https://raspberrypi.stackexchange.com/questions/108803/issue-with-nodogsplash-saying-it-needed-updateed-libmicrohttpd-dev-but-i-seems&quot;&gt;组件过时异常&lt;/a&gt;，可在配置文件中添加字段&lt;code&gt;se_outdated_mhd 1&lt;/code&gt;避开此异常。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;带认证的wifi在商业活动中越来越常见，开源社区中，&lt;code&gt;nodogsplash&lt;/code&gt;是其中一种实现方式，在少量限制的情况下，提供了足够的灵活性让你用熟悉的方式像搭建其他网站一样搭建wifi认证页面。最终，把你的前端能力延伸到路由器上。&lt;/p&gt;
&lt;h4&gt;参考文献&lt;/h4&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/nodogsplash/nodogsplash&quot;&gt;nodogsplash的github地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://nodogsplashdocs.readthedocs.io/en/stable/&quot;&gt;nodogsplash的官方文档&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://blogs.arubanetworks.com/industries/rfc-7710-captive-portal-identification-using-dhcp-or-router-advertisements-ras/&quot;&gt;captive-portal和rfc-7710文献关联&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://wiki.mozilla.org/QA/Captive_Portals&quot;&gt;Captive-Portal的wiki&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pimylifeup.com/raspberry-pi-wireless-access-point/&quot;&gt;树莓派搭建wifi热点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://pimylifeup.com/raspberry-pi-captive-portal/&quot;&gt;树莓派搭建captive-portal&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[试了就戒不掉的CI工具-dangerjs]]></title><description><![CDATA[在开源社区中，danger的使用尤其普遍，它可以拿来自动判断每个人提交的代码合并请求（github中叫Pull Request，下文简称PR，gitlab中叫Merge Request，下文简称MR…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-07-14-the-addicting-ci-tool-dangerjs/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-07-14-the-addicting-ci-tool-dangerjs/</guid><pubDate>Tue, 14 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在开源社区中，danger的使用尤其普遍，它可以拿来自动判断每个人提交的代码合并请求（github中叫Pull Request，下文简称PR，gitlab中叫Merge Request，下文简称MR）是否符合规范，自动化一些费时费力的人工检查，从而保证代码质量，是项目管理的利器。&lt;/p&gt;
&lt;p&gt;比如开源项目&lt;a href=&quot;https://github.com/styled-components/styled-components&quot;&gt;styled-componet&lt;/a&gt;的这个自动回复机器人就是用danger实现的。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/1734543bf6969c3a?w=777&amp;#x26;h=199&amp;#x26;f=png&amp;#x26;s=33630&quot;&gt;&lt;/p&gt;
&lt;p&gt;Danger最初是由ruby社区发展起来，之后增加了对js语言的支持，衍生出DangerJs。从它的标语中即可看出此工具存在的意义：&lt;strong&gt;Stop saying “you forgot to …” in code review&lt;/strong&gt;，实际上，此工具可做的事情要远比标语中描述的多。&lt;/p&gt;
&lt;p&gt;在整个代码合并流程中，danger的位置通常在测试和代码规范化检查的后一步，人工检查的前一步，相当于是足球中的清道夫的角色，&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/1734559a0448b54a?w=2060&amp;#x26;h=360&amp;#x26;f=png&amp;#x26;s=38537&quot;&gt;&lt;/p&gt;
&lt;p&gt;danger常见的使用场景是：通过自定制的脚本自动化处理一些费神的人工检查。我以前在项目中使用dangerjs在gitlab上实现过这样的检查：合并代码时有没有勾选“合并后删除远端分支”的复选框，有没有勾选“合并时压缩git节点”的复选框，有没有在合并标题中写上对应电子看板的任务卡ID等等，如果没有操作这些则禁止代码合并，及其方便的规范了整个团队的git开发流程。&lt;/p&gt;
&lt;p&gt;在上篇&lt;a href=&quot;https://juejin.im/post/6847902224794943495&quot;&gt;介绍lerna的文章&lt;/a&gt;里，用dangerjs实现了子项目权限检查：判定当前提交人是否满足某个目录的提交权限，不满足则不允许代码合并，效果如下图所示。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/1734543212ec650e?w=2018&amp;#x26;h=912&amp;#x26;f=png&amp;#x26;s=288646&quot;&gt;&lt;/p&gt;
&lt;h3&gt;安装Dangerjs&lt;/h3&gt;
&lt;p&gt;Dangerjs支持github和gitlab两大代码托管平台，也支持私有gitlab服务器，不过它对github的支持最好，简单几步在即可在一个github项目中加入danger检查。&lt;/p&gt;
&lt;p&gt;在你的项目中，dangerjs用起来就像其他任何npm包一样，一行命令即可安装。（注意包名没有js后缀）&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn add -D danger&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;设置github的token&lt;/h3&gt;
&lt;p&gt;danger需要使用你的token授权来做相应操作，比如添加评论到对应的PR下方给出提示。你可以点击&lt;a href=&quot;https://github.com/settings/tokens/new&quot;&gt;此链接&lt;/a&gt;在github上生成对应token，token的名称可以随便起，权限要记得给足。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/173456ceceb894c1?w=1400&amp;#x26;h=790&amp;#x26;f=jpeg&amp;#x26;s=132923&quot;&gt;&lt;/p&gt;
&lt;h3&gt;将token保存到环境变量中&lt;/h3&gt;
&lt;p&gt;需要把token的变量名命名为&lt;code&gt;DANGER_GITHUB_API_TOKEN&lt;/code&gt;，并且保存在CI的配置里，比如我在github中使用了circleci作为持续集成的工具，token就需要保存到如下位置，见截图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/14/1734a263655eea6e?w=2686&amp;#x26;h=1102&amp;#x26;f=png&amp;#x26;s=262091&quot;&gt;&lt;/p&gt;
&lt;p&gt;注意，如果是gitlab公网上的项目，那变量名就不一样了，需设置为&lt;code&gt;DANGER_GITLAB_API_TOKEN&lt;/code&gt;, 如果是私有gitlab服务器，还需要添加另外一个变量&lt;code&gt;DANGER_GITLAB_HOST&lt;/code&gt;将地址指向你自己的服务器，详情可参考&lt;a href=&quot;https://danger.systems/js/usage/gitlab.html&quot;&gt;官网链接&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;创建dangerfile.js文件&lt;/h3&gt;
&lt;p&gt;项目根目录下创建dangerfile.js文件用于编写对应的脚本，比如下面几行代码就是最常用的写法。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import { danger, fail, warn } from &amp;#39;danger&amp;#39;

fail(&amp;#39;This is a failure message&amp;#39;) // 显示一条错误信息

warn(&amp;#39;This is a warn message&amp;#39;) // 显示一条警告信息

const { title } = danger.github.pr
if (!title.startsWith(&amp;#39;feature/&amp;#39;)) {
	fail(&amp;#39;标题必须要由&amp;quot;feature/&amp;quot;开头&amp;#39;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;本地测试danger脚本&lt;/h3&gt;
&lt;p&gt;在脚本正式推向CI环境前，可以本地测试一下脚本是否符合预期。首先要创建Pull Requst，然后获取此PR的地址，之后使用npm或者yarn执行命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;yarn danger pr 创建的PR的地址&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;此时，你可能会碰到下面这样的提示，这是因为还没有在本地设置token变量。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/14/1734a3ec4d88347d?w=1760&amp;#x26;h=214&amp;#x26;f=png&amp;#x26;s=79558&quot;&gt;&lt;/p&gt;
&lt;p&gt;本地直接执行一下命令来声明变量即可。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;export DANGER_GITHUB_API_TOKEN=xxxxxx&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;设置token变量后重新执行&lt;code&gt;danger pr&lt;/code&gt;的命令。访问对应的PR地址，如果看到下图这样的效果，说明你写的dangerjs脚本生效了。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/14/1734a46cfe487cf1?w=1886&amp;#x26;h=822&amp;#x26;f=png&amp;#x26;s=164780&quot;&gt;&lt;/p&gt;
&lt;p&gt;最后，把&lt;code&gt;yarn danger ci&lt;/code&gt;或者&lt;code&gt;npm danger ci&lt;/code&gt;放在你的CI文件中的合适位置，这样danger就添加完成了。&lt;/p&gt;
&lt;p&gt;另外，你可以申请一个github账号名为’xxxx-bot’，再贴一张机器人图片作为头像，并用此账号的token作为变量来自动回复，最终能让整个效果更显技术含量。 &lt;/p&gt;
&lt;h3&gt;能获取到的数据&lt;/h3&gt;
&lt;p&gt;除了标题之外，danger能获取当前PR中的各种信息字段，比如用户信息、修改的文件、代码审核人、代码合并的配置等等，从下面的截图里包含了一些常用字段。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/14/1734a52d35926ddb?w=2268&amp;#x26;h=1670&amp;#x26;f=png&amp;#x26;s=430546&quot;&gt;&lt;/p&gt;
&lt;p&gt;除此之外，&lt;a href=&quot;https://danger.systems/js/reference.html&quot;&gt;dangerjs的官网&lt;/a&gt;也给出了详细的类型数据，你可以根据需要定制符合自己项目需求的检查脚本。&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;danger可以在合并代码时提供自定义的合并规则，能规范整个项目的开发流程，把它整合到CI中能帮你自动化很多繁琐的人工检查，无论是开源项目还是日常开发项目，danger都是项目流程管理的利器，一旦试过你就再也戒不掉。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/@ivan.ha/integrate-danger-js-in-5-minutes-55515bc5355d&quot;&gt;integrate-danger-js-in-5-minutes&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://danger.systems/js/&quot;&gt;dangerjs官网&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/twomeetings/lerna-example/pull/3&quot;&gt;文章中的PR地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[大前端项目代码重用，也许lerna是最好的选择]]></title><description><![CDATA[我前段时间参与了一个react为主的大前端项目，覆盖Web、Android、Ios三个平台。由于整个业务逻辑侧重在手机端，且Web端也是到了项目中期才开始启动，我分别以react-native和react分开建了两个项目。 可是，后端微服务集群是同一个，两个项目调用的API…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-07-10-you-should-use-lerna-for-sharing-code/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-07-10-you-should-use-lerna-for-sharing-code/</guid><pubDate>Fri, 10 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;我前段时间参与了一个&lt;code&gt;react&lt;/code&gt;为主的大前端项目，覆盖Web、Android、Ios三个平台。由于整个业务逻辑侧重在手机端，且Web端也是到了项目中期才开始启动，我分别以&lt;code&gt;react-native&lt;/code&gt;和&lt;code&gt;react&lt;/code&gt;分开建了两个项目。&lt;/p&gt;
&lt;p&gt;可是，后端微服务集群是同一个，两个项目调用的API大多一样，导致两个项目中不可避免的出现了一些重复逻辑。比如说写在redux中的业务逻辑代码，写在http拦截器中的请求处理代码等等，这些重复的部分从目录名和文件名即可肉眼看出。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/173452607adea86e?w=1584&amp;#x26;h=1050&amp;#x26;f=png&amp;#x26;s=270873&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/17345627a10f22a2?w=1864&amp;#x26;h=1128&amp;#x26;f=png&amp;#x26;s=352870&quot;&gt;&lt;/p&gt;
&lt;p&gt;我尝试了将重复部分封装成独立的&lt;code&gt;npm&lt;/code&gt;包供两个项目引用，但这个做法仅适用于变化频率较小的工具类代码，一旦封装了变化频繁的业务逻辑代码，用起来也麻烦不断。首先，抽出到项目之外但不易开发和调试，其次，在项目开发过程中业务代码更新太频繁，常常要不断升级版本。权衡利弊，最终得不偿失。&lt;/p&gt;
&lt;p&gt;那么，有没有办法更好的重用这部分代码逻辑呢？有没有办法把这两个项目的通用代码抽取成独立项目，但是又能避开封装成独立&lt;code&gt;npm&lt;/code&gt;包的弊端呢？&lt;/p&gt;
&lt;p&gt;我最近尝试引入&lt;a href=&quot;https://github.com/lerna/lerna&quot;&gt;lerna框架&lt;/a&gt;，把这个大前端项目架构作为参照物来改造，惊喜的发现它不但能解决当时项目的痛点，还能额外带来一些多项目管理相关的好处。&lt;/p&gt;
&lt;p&gt;事实上，开源社区早已有很多项目使用了这种多项目合而为一的方案，且采用了lerna框架的代码库也大多耳熟能详，比如国外的有&lt;a href=&quot;https://github.com/babel/babel&quot;&gt;babel&lt;/a&gt;、&lt;a href=&quot;https://github.com/facebook/create-react-app&quot;&gt;create-react-app&lt;/a&gt;、&lt;a href=&quot;https://github.com/ReactTraining/react-router&quot;&gt;react-router&lt;/a&gt;、&lt;a href=&quot;https://github.com/facebook/jest&quot;&gt;jest&lt;/a&gt;、以及国内跨端小程序框架&lt;a href=&quot;https://github.com/NervJS/taro&quot;&gt;Taro&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;最后经过改造，两个项目合并成一个，重复的代码逻辑也被抽取成另一个独立项目，整个项目结构变成了下面图示这样。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/17345266371693e2?w=1666&amp;#x26;h=1130&amp;#x26;f=png&amp;#x26;s=246949&quot;&gt;&lt;/p&gt;
&lt;h3&gt;引入lerna&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;lerna&lt;/code&gt;的名字来源于希腊神话中的九头蛇海德拉（Lernaean Hydra），拿它形容多项目工程是再贴切不过了。&lt;/p&gt;
&lt;p&gt;&lt;code&gt;lerna&lt;/code&gt;的引入比想象中简单，其实，与其说引入&lt;code&gt;lerna&lt;/code&gt;，倒不如说是导入到&lt;code&gt;lerna&lt;/code&gt;更合适，因为具体的做法是通过命令行创建了一个新的&lt;code&gt;lerna&lt;/code&gt;项目，然后把所有项目导入进去。而且在导入的同时，每个项目的git提交记录也都合并在了一起。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;lerna init
lerna import 你本地的项目路径&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;每个被导入的项目都会被存放在根路径的packages目录下，下面是我demo项目的截图，一共引入了三个子项目：rntest, web-app, shared。分别代表mobile，web和可重用的逻辑代码。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/10/17336c236f9a7a04?w=726&amp;#x26;h=850&amp;#x26;f=png&amp;#x26;s=97041&quot;&gt;&lt;/p&gt;
&lt;h3&gt;使用lerna来管理项目依赖&lt;/h3&gt;
&lt;p&gt;引入&lt;code&gt;lerna&lt;/code&gt;后，第一件事就是要处理安装依赖的问题，我们需要用&lt;code&gt;lerna add&lt;/code&gt; 命令来代替我们习惯的&lt;code&gt;npm&lt;/code&gt;或&lt;code&gt;yarn&lt;/code&gt;，比如说给rntest项目安装&lt;code&gt;lodash&lt;/code&gt;，就要执行下面的命令。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;lerna add lodash --scope=rntest&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;不过，执行后你会发现其他项目中package-lock.json都发生了变化，让人非常困惑，这背后的原因是跟添加依赖后自动执行的安装命令&lt;code&gt;lerna bootstrap&lt;/code&gt;有关。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/10/17336ce90943c4c5?w=1590&amp;#x26;h=692&amp;#x26;f=png&amp;#x26;s=306642&quot;&gt;&lt;/p&gt;
&lt;h4&gt;lerna的依赖提升&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;lerna&lt;/code&gt;可以通过&lt;code&gt;lerna bootstrap&lt;/code&gt;一行命令安装所有子项目的依赖包，而且在安装依赖时还有依赖提升功能，所谓“依赖提升”，就是把所有项目npm依赖文件都提升到根目录下，这样能避免相同依赖包在不同项目安装多次。比如多个项目都用了&lt;code&gt;redux&lt;/code&gt;，通过依赖提升，多个项目一共只需要下载一次即可。不过，需要额外的参数&lt;code&gt;--hoist&lt;/code&gt;让依赖提升生效。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;lerna bootstrap --hoist&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;但是自动执行&lt;code&gt;lerna bootstrap&lt;/code&gt;命令是不带依赖提升参数的，这就导致上面每个项目的lock文件都会被修改的原因。&lt;/p&gt;
&lt;p&gt;当然，要解决这个问题也容易，可以通过&lt;code&gt;lerna&lt;/code&gt;的配置来避免npm对lock文件的修改即可，写法如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/10/17336dd6146615f4?w=574&amp;#x26;h=610&amp;#x26;f=png&amp;#x26;s=45981&quot;&gt;&lt;/p&gt;
&lt;h4&gt;yarn是lerna的最佳搭档&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;lerna&lt;/code&gt;默认使用&lt;code&gt;npm&lt;/code&gt;作为安装依赖包工具，但也可以选择其他工具。&lt;code&gt;yarn&lt;/code&gt;在1.0版本之后提供了workspaces的功能，该功能从更底层的地方提供了依赖提升，做的事情跟&lt;code&gt;lerna&lt;/code&gt;如出一辙。把它跟&lt;code&gt;lerna&lt;/code&gt;放在一起看，简直就像是为&lt;code&gt;lerna&lt;/code&gt;量身定做一样。因此，推荐在lerna中搭配yarn一起使用。&lt;/p&gt;
&lt;p&gt;把npm替换成yarn只需在lerna的配置文件添加两行代码即可，配置完以后立刻顺畅百倍。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/10/17336e46c6eed674?w=538&amp;#x26;h=386&amp;#x26;f=png&amp;#x26;s=35002&quot;&gt;&lt;/p&gt;
&lt;h3&gt;高效的代码重用&lt;/h3&gt;
&lt;p&gt;在我参与的这个大前端项目里，多端之间代码重复的部分包含&lt;code&gt;redux&lt;/code&gt;中的业务逻辑、http请求的处理、代码规范工具的检查、&lt;code&gt;git&lt;/code&gt;钩子中的自定义脚本等等。在&lt;code&gt;lerna&lt;/code&gt;架构下，前两者可直接抽取到一个独立的项目，然后被其他项目引用，比如在我的demo中，可以像其他依赖包一样直接引入&lt;code&gt;shared&lt;/code&gt;项目, lerna会自动识别并把它导向内部项目。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import shared from &amp;#39;shared&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这跟直接封装成&lt;code&gt;npm&lt;/code&gt;包的一大区别就是实时更新，修改立刻可见，就像在同一个项目一样，不影响开发和调试。&lt;/p&gt;
&lt;h4&gt;git钩子和自定义脚本的重用&lt;/h4&gt;
&lt;p&gt;我尝试把处理&lt;code&gt;git&lt;/code&gt;钩子的工具&lt;code&gt;husky&lt;/code&gt;安装到了根目录，触发的事件和自定义脚本能覆盖到每个项目，给这部分代码重用带来了极大便利。比如，不少项目会添加自定义脚本来约束&lt;code&gt;git commit&lt;/code&gt;提交时的消息描述，在&lt;code&gt;lerna&lt;/code&gt;架构下，只需写一次即可。&lt;/p&gt;
&lt;h4&gt;eslint的重用&lt;/h4&gt;
&lt;p&gt;那些常常需要在根目录添加配置文件的第三方依赖，比如&lt;code&gt;eslint&lt;/code&gt;、&lt;code&gt;prettier&lt;/code&gt;、&lt;code&gt;babel&lt;/code&gt;等，在&lt;code&gt;lerna&lt;/code&gt;中无法简单粗暴的提升合并到一处。因此，对于&lt;code&gt;eslint&lt;/code&gt;这种前端开发已不可或缺的工具，可以尝试将所有配置项抽取到独立项目，然后安装第三方依赖的方式引入，类似&lt;code&gt;eslint-config-airbnb&lt;/code&gt;，&lt;code&gt;eslint-config-prettier&lt;/code&gt;，&lt;code&gt;eslint-config-google&lt;/code&gt;这样。&lt;/p&gt;
&lt;p&gt;不得不说，即便不用&lt;code&gt;lerna&lt;/code&gt;框架我们也可以这么做，只不过在&lt;code&gt;lerna&lt;/code&gt;框架下修改立刻可见，方便了调试和开发。&lt;/p&gt;
&lt;h3&gt;lerna框架下的CI/CD&lt;/h3&gt;
&lt;p&gt;多项目的结构无疑给&lt;code&gt;CI/CD&lt;/code&gt;带来挑战，好在主流的CI框架能完美解决这个问题。比如在gitlab上，&lt;code&gt;only/changes&lt;/code&gt;参数完全满足了我们的需求，让我们可以为每一个子项目设置单独的pipeline，比如现在我们设置一个pipeline，只当rntest项目下的文件被修改时才会触发：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/10/1733709cb0553f09?w=1022&amp;#x26;h=470&amp;#x26;f=png&amp;#x26;s=56019&quot;&gt;&lt;/p&gt;
&lt;p&gt;在lerna框架下，所有项目都合在一个工程里，但&lt;code&gt;CI/CD&lt;/code&gt;并不必这样。通过把脚本中的关键参数配置到&lt;code&gt;CI/CD&lt;/code&gt;的项目内里，共用同一份&lt;code&gt;.gitlab-ci.yml&lt;/code&gt;文件，从而能够实现每个子项目对应一个独立的&lt;code&gt;CI/CD&lt;/code&gt;项目，最终&lt;code&gt;CI/CD&lt;/code&gt;结构如下图：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/10/1733717fab7eb8e3?w=1332&amp;#x26;h=846&amp;#x26;f=png&amp;#x26;s=175590&quot;&gt;&lt;/p&gt;
&lt;h3&gt;lerna框架下的子项目权限&lt;/h3&gt;
&lt;p&gt;由于所有的项目都归并到了一个&lt;code&gt;lerna&lt;/code&gt;工程下，一旦有了访问权限意味着你可以修改所有子项目中的代码，在实际的开发工作中多多少少会带来一些麻烦。比如说，开发web和开发mobile平台的是两个不同的团队，假如我作为web组的一员，一不小心修改了或删除了mobile项目的文件该怎么办？假如不加入任何限制，这种事情迟早会发生，我想这可能是&lt;code&gt;lerna&lt;/code&gt;框架与生俱来的的痛点。&lt;/p&gt;
&lt;p&gt;不幸的是，在&lt;code&gt;lerna&lt;/code&gt;框架下，gitlab或github这类第三方代码托管平台，本身的权限管理功能无法解决这问题。但好在有其他工具的帮助可以缓解这种痛，我尝试用来约束开源贡献者提交PR规范的工具&lt;code&gt;dangerjs&lt;/code&gt;来完成权限分隔，利用的信息就是当前gitlab账号的用户名，看起来效果还不错。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/1734528ea00cdce7?w=2134&amp;#x26;h=1834&amp;#x26;f=png&amp;#x26;s=479655&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到，此工具会在合并MR时，判断出我gitlab账号没有权限修改rntest子项目内的文件，从而禁止合并此MR，并将这些信息自动添加到MR的评论里。当然，脚本判断是自己写的仅用作演示，逻辑比较简陋，脚本代码如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/13/17345291a0c5b1f1?w=2838&amp;#x26;h=988&amp;#x26;f=png&amp;#x26;s=631394&quot;&gt;&lt;/p&gt;
&lt;p&gt;关于&lt;code&gt;dangerjs&lt;/code&gt;的部分我会另写一篇文章详细介绍。&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;大前端项目将会是前端发展的趋势，如何更好的管理大前端项目是每一位前端开发躲不开的课题。&lt;code&gt;lerna&lt;/code&gt;框架通过合而为一的理念提供了一种解决方案，通过扬长避短，我们可以发挥出&lt;code&gt;lerna&lt;/code&gt;的最大效用。假如你还没有用过，也许，下一个项目就可以试试看。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;相关资料&lt;/strong&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://classic.yarnpkg.com/en/docs/workspaces/&quot;&gt;yarn的workspaces&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/lerna/lerna&quot;&gt;lerna的github地址&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://gitlab.com/twomeetings/lerna-demo&quot;&gt;文章中的demo&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;</content:encoded></item><item><title><![CDATA[如何编写hooks风格的redux组件]]></title><description><![CDATA[Hooks特性在React的16.…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-07-01-how-to-write-hooks-like-component-in-redux/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-07-01-how-to-write-hooks-like-component-in-redux/</guid><pubDate>Wed, 01 Jul 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;Hooks特性在React的16.8版本被引入，在解决组件重用和生命周期逻辑破碎两大难题的同时，极大简化了组件写法，而且兼容旧写法，即便不想学也没关系，向开发者释放了极大的善意。&lt;/p&gt;
&lt;p&gt;可是，组件写法的改变或多或少会让人有些顾虑，尤其是和第三方组件集成，开发社区中也出现了一些类似“Redux是否要被Hooks取代”的声音，就像之前的React Context特性出现的时候一样，大伙的第一反应总是先问Redux是不是要被取代了，即使两者之间并无太多冲突，不过这也侧面反映了Redux框架在社区中的受众之广。&lt;/p&gt;
&lt;p&gt;实际上，React-Redux组件库作为粘合剂从7.1.0开始已支持Hooks特性，这让我们写redux组件的时候不再需要connect方法，我们通过一个例子来展示如何写Hooks风格的redux组件。下面代码展示了一个复选框，使用了常见的connect方法将组件和store连接起来。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { Component } from &amp;quot;react&amp;quot;;
import { connect } from &amp;quot;react-redux&amp;quot;;
import { toggleSwitch } from &amp;quot;./UiReducer&amp;quot;;

class Toggle extends Component {
  render() {
    const { ui, toggleSwitch } = this.props;
    return (
      &amp;lt;div&amp;gt;
        &amp;lt;div&amp;gt;{JSON.stringify(ui)}&amp;lt;/div&amp;gt;
        &amp;lt;input
          type=&amp;quot;checkbox&amp;quot;
          value={ui.toggle}
          onChange={toggleSwitch}
        /&amp;gt;
      &amp;lt;/div&amp;gt;
    );
  }
}

const mapStateToProps = ({ ui }) =&amp;gt; ({
  ui
});

export default connect(
  mapStateToProps,
  { toggleSwitch }
)(Toggle);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;最终效果如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/1/1730795a97cf6eff?w=374&amp;#x26;h=202&amp;#x26;f=gif&amp;#x26;s=28977&quot;&gt;&lt;/p&gt;
&lt;p&gt;那么，接下来我们尝试把这个组件重构成hooks风格的redux组件。&lt;/p&gt;
&lt;h4&gt;第一步：重构成函数组件&lt;/h4&gt;
&lt;p&gt;用函数来代替class组件，并且我们将ui和toggleSwitch从组件属性中解构出来，这一步相对简单，代码也得到了极大的缩减。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { connect } from &amp;quot;react-redux&amp;quot;;
import { toggleSwitch } from &amp;quot;./UiReducer&amp;quot;;

const Toggle = ({ ui, toggleSwitch }) =&amp;gt; (
  &amp;lt;div&amp;gt;
    &amp;lt;div&amp;gt;{JSON.stringify(ui)}&amp;lt;/div&amp;gt;
    &amp;lt;input type=&amp;quot;checkbox&amp;quot; value={ui.toggle} onChange={toggleSwitch} /&amp;gt;
  &amp;lt;/div&amp;gt;
);

const mapStateToProps = ({ ui }) =&amp;gt; ({
  ui
});

export default connect(
  mapStateToProps,
  { toggleSwitch }
)(Toggle);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;第二步：使用useSelector&lt;/h4&gt;
&lt;p&gt;现在，我们不再使用connect方法，react-redux提供了useSeletor方法让我们可以直接从hook中读取store的值。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import { connect, useSelector } from &amp;quot;react-redux&amp;quot;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;const Toggle = ({ toggleSwitch }) =&amp;gt; {
  const ui = useSelector(state =&amp;gt; state.ui);
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div&amp;gt;{JSON.stringify(ui)}&amp;lt;/div&amp;gt;
      &amp;lt;input type=&amp;quot;checkbox&amp;quot; value={ui.toggle} onChange={toggleSwitch} /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;第三步：使用useDispatch&lt;/h4&gt;
&lt;p&gt;像第二步一样，我们可以直接通过hook获取到dispatch方法，然后根据需要执行自定义的action。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import { useSelector, useDispatch } from &amp;quot;react-redux&amp;quot;;

...

const dispatch = useDispatch();&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;完成&lt;/h4&gt;
&lt;p&gt;最终，我们的代码会被重构成下面这样：&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;quot;react&amp;quot;;
import { useSelector, useDispatch } from &amp;quot;react-redux&amp;quot;;
import { TOGGLE } from &amp;quot;./UiReducer&amp;quot;;

const Toggle = () =&amp;gt; {
  const ui = useSelector(state =&amp;gt; state.ui);
  const dispatch = useDispatch();
  return (
    &amp;lt;div&amp;gt;
      &amp;lt;div&amp;gt;{JSON.stringify(ui)}&amp;lt;/div&amp;gt;
      &amp;lt;input
        type=&amp;quot;checkbox&amp;quot;
        value={ui.toggle}
        onChange={() =&amp;gt; dispatch({ type: TOGGLE })}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
  );
};

export default Toggle;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可以看到除了代码的简化外，相比较原connect写法，store中的值不再从组件的属性传入，假如你使用typescript或flow，也省却了属性中对类型的声明，更进一步简化了组件写法，从这个示例中能明显感受到Hooks带来的好处，也许，从现在开始就可以把connect方法扔掉了。&lt;/p&gt;
&lt;blockquote&gt;
&lt;h4&gt;参考资料&lt;/h4&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://reactjs.org/docs/hooks-intro.html&quot;&gt;Hooks-Intro&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/better-programming/how-to-use-redux-with-react-hooks-5422a7ceae6e&quot;&gt;how to use redux with react hooks&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/1/17308d8ff376dd37?w=1702&amp;#x26;h=806&amp;#x26;f=png&amp;#x26;s=162909&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[如何顺滑的展示大数据列表]]></title><description><![CDATA[每每谈到前端性能优化，大数据列表的呈现总是一个老生常谈的话题。基于浏览器本身处理DOM的方式，一旦列表数据足够大时，总是不可避免的出现CUP…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-06-18-how-to-render-big-data-with-list/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-06-18-how-to-render-big-data-with-list/</guid><pubDate>Thu, 18 Jun 2020 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;每每谈到前端性能优化，大数据列表的呈现总是一个老生常谈的话题。基于浏览器本身处理DOM的方式，一旦列表数据足够大时，总是不可避免的出现CUP和内存占用导致的卡顿问题，因此，针对大数据列表，只能使用特别的方式来呈现。&lt;/p&gt;
&lt;p&gt;面对这个问题时，直觉反应就是切分：切成小块再呈现。比如，现在有10万条数据，仅仅拿出前1000条呈现出来，随着滚动条的滑动再逐步展示后面数据。然而，这种方式引起的列表高度变化会给用户带来非常糟糕的滑动体验，无论是补充数据还是把原列表换掉，使用起来跟标准滚动条差别非常大。因此，仅仅是切分还远远不够。&lt;/p&gt;
&lt;h3&gt;定高&lt;/h3&gt;
&lt;p&gt;为了防止列表高度变化带来的滚动体验问题，需要在大列表呈现时就先计算好高度。也就是说当要呈现10万条数据时，即使只先呈现前1000条，10W条数据的总高度要先被算好并设置在最外层的容器上。目的是当滑动时，呈现的数据变化，但容器总高度不变，这样体验起来才会和普通滚动条一致。&lt;/p&gt;
&lt;p&gt;给10万条数据定高，就意味着你需要知道每一条数据呈现出来的高度是多少，在代码实现层面，可以拿出其中一条数据展示出来获取其高度。如此一来，不但总容器的高度能确定，每一条数据在纵坐标的起始位置也能定下，为后续的滑动展示提供基础。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c4af4d55a1686?w=1124&amp;#x26;h=948&amp;#x26;f=png&amp;#x26;s=40550&quot; alt=&quot;通过单项定高&quot;&gt;&lt;/p&gt;
&lt;h3&gt;分组&lt;/h3&gt;
&lt;p&gt;一旦高度定下，就可以根据滚动条的的位置展示或隐藏列表数据，但具体的代码实现却不得不考虑性能问题，因为需要遍历整个列表逐个判断，10W条数据遍历一次也是特别大的运算，更糟糕的是，滚动条滑动的事件触发是非常频繁的。&lt;/p&gt;
&lt;p&gt;解决方案就是分组，即将100个或1000个划分为一组，以组为单位进行判断，同时，需要在定高时根据每一项高度计算出组的纵坐标起始位置。如此一来，遍历时以组为单位大大减少了计算量，10W条数据，1000个为1组，遍历起来也就只有100组而已。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c4b072b03ad1e?w=1104&amp;#x26;h=832&amp;#x26;f=png&amp;#x26;s=42233&quot;&gt;&lt;/p&gt;
&lt;p&gt;分组后，滑动展示时便可以灵活制定展示规则，比如滚动条划过当前组高度一大半以后展示下一组等。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c4ad0f7b9b623?w=824&amp;#x26;h=970&amp;#x26;f=gif&amp;#x26;s=549313&quot; alt=&quot;分组后的滑动展示预览图&quot;&gt;&lt;/p&gt;
&lt;h3&gt;分组算法&lt;/h3&gt;
&lt;p&gt;因为看了国外一篇写大数据列表的文章有感，才写了此文。值得一提的是，那篇文章中的分组方式很特别，利用二叉树算法，一个简洁递归就把数据分好了。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;recursiveSplit =(data)=&amp;gt; {
    if(data.length / 2 &amp;gt; this.minimumStackSize) {
      let mid = Math.floor(data.length/2, 10);
      let node = { 
        parent: true,
        getParent: ()=&amp;gt; data,
        data: [this.recursiveSplit(data.slice(0, mid)), this.recursiveSplit(data.slice(mid, data.length+1))]
      }
      return node;
    }
    return {
      parent: false,
      data
    }
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;作者最终Demo的效果如图，相关链接我已贴在文章底部。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/18/172c4b635d38056a?w=1204&amp;#x26;h=963&amp;#x26;f=gif&amp;#x26;s=2218960&quot; alt=&quot;demo效果展示图&quot;&gt;&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;处理大数据列表的呈现，关键点有两个，一是定高，二是分组。定高保证了选择性呈现数据时滚动条的正常体验，分组则处理了频繁遍历带来的性能消耗。&lt;/p&gt;
&lt;h5&gt;参考资料：&lt;/h5&gt;
&lt;p&gt;&lt;a href=&quot;https://medium.com/better-programming/how-i-rendered-a-massive-list-in-react-without-memory-and-cpu-issues-7ac6fe6a697b&quot;&gt;https://medium.com/better-programming/how-i-rendered-a-massive-list-in-react-without-memory-and-cpu-issues-7ac6fe6a697b&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://react-eternal-list.rinas.in/&quot;&gt;https://react-eternal-list.rinas.in/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/rinasm/react-eternal-list#readme&quot;&gt;https://github.com/rinasm/react-eternal-list#readme&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/1/17308da600ad738a?w=1702&amp;#x26;h=806&amp;#x26;f=png&amp;#x26;s=162909&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[web端断点续传的思路和实现]]></title><description><![CDATA[看过一道面试题要求实现断点续传，当时脑海大致想了一下实现思路，没完全想通，感觉涉及的知识点挺多，于是花了些时间用react和nodejs实现了一个简易版，并梳理了实现思路和用到的知识点。 简单汇总，用到的知识点如下： 利用FileReader将上传文件切片 用MD…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/2020-06-11-how-to-implement-resumable-upload/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/2020-06-11-how-to-implement-resumable-upload/</guid><pubDate>Thu, 11 Jun 2020 00:00:00 GMT</pubDate><content:encoded>&lt;!-- ---
title: &apos;&apos;
--- --&gt;
&lt;p&gt;看过一道面试题要求实现断点续传，当时脑海大致想了一下实现思路，没完全想通，感觉涉及的知识点挺多，于是花了些时间用react和nodejs实现了一个简易版，并梳理了实现思路和用到的知识点。&lt;/p&gt;
&lt;p&gt;简单汇总，用到的知识点如下：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;利用FileReader将上传文件切片&lt;/li&gt;
&lt;li&gt;用MD5算法获取文件唯一性标识&lt;/li&gt;
&lt;li&gt;用XHR显示上传进度&lt;/li&gt;
&lt;li&gt;比对文件大小，计算续传的开始节点&lt;/li&gt;
&lt;li&gt;自定制对文件的保存方法，确保异常终止时也能将未传完文件保存下来&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;&lt;a href=&quot;https://github.com/twomeetings/resumable-upload-demo&quot;&gt;demo可以在此处下载&lt;/a&gt;，另外，推荐使用chrome本身的网络限速来方便的测试断点续传功能。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/6/11/172a060c655071e1?w=1338&amp;#x26;h=510&amp;#x26;f=png&amp;#x26;s=179173&quot; alt=&quot;chrome网络限速&quot;&gt;&lt;/p&gt;
&lt;h3&gt;前端部分&lt;/h3&gt;
&lt;p&gt;框架选择上用了React作前端呈现，利用axois做网络请求，用js-md5来获取文件唯一性标识。&lt;/p&gt;
&lt;h4&gt;先说断点&lt;/h4&gt;
&lt;p&gt;断点的基础是将文件分段，在web端可用&lt;a href=&quot;https://developer.mozilla.org/zh-CN/docs/Web/API/FileReader&quot;&gt;FileReader&lt;/a&gt;类将文件以Buffer的形式读取，之后用原型链上的slice方法分段处理。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;const reader = new FileReader()
reader.readAsArrayBuffer(uploadedFile)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;此外，由于上传文件不通过html表单提交，在js端操作上传就需要使用FormData类来封装上传数据。&lt;/p&gt;
&lt;h4&gt;再说续传&lt;/h4&gt;
&lt;p&gt;续传的前提是需要能识别出再次上传的文件是否与上一次相同，即必须先获取文件唯一性标识，其中MD5算法即可满足要求，因此我使用了第三方依赖js-md5。&lt;/p&gt;
&lt;p&gt;另外，续传开始时需要知道从哪开始续，我在后端提供一个api接口，通过文件md5的值查询对应文件的大小，然后由前端再次上传前调用，并比较计算出续传的开始位置。&lt;/p&gt;
&lt;p&gt;后端的具体实现会在下文提及。&lt;/p&gt;
&lt;h4&gt;上传进度&lt;/h4&gt;
&lt;p&gt;刚开始的时候，我想简单的使用fetch来处理请求，但很快发现fetch本身的设计无法获取上传进度信息，底层实现上只能通过XHR拿到，因此引入了基于XHR的axois来处理上传。&lt;/p&gt;
&lt;h3&gt;后端部分&lt;/h3&gt;
&lt;p&gt;后端使用了koa加formidable组件来处理上传请求，尽管formidable稍显过时，网上更多人推荐multer，我对比了两者，最后决定选用formidable是因为它满足需求且文档详尽。&lt;/p&gt;
&lt;h4&gt;自定义formidable中间件&lt;/h4&gt;
&lt;p&gt;为了能更灵活控制数据处理的部分，我参考了&lt;a href=&quot;https://github.com/rkusa/koa-formidable/blob/master/index.js&quot;&gt;koa-formidable&lt;/a&gt;写法，实现了一个自定义koa中间件。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;const koaMiddleware = opt =&amp;gt; {
	const tempFileDir = `./upload/tmp/`
	if (!fs.existsSync(tempFileDir, { recursive: true })) {
		fs.mkdirSync(tempFileDir)
	}

	return async function(ctx, next) {
		const form = formidable.IncomingForm()
		for (const key in opt) {
			form[key] = opt[key]
		}
		await new Promise((resolve, reject) =&amp;gt; {
			form.parse(ctx.req, (err, fields, files) =&amp;gt; {
				if (err) {
					reject(err)
				} else {
					ctx.request.body = fields
					ctx.request.files = files
					resolve()
				}
			})
		})

		await next()
	}
}

export default koaMiddleware&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;接受分段数据&lt;/h4&gt;
&lt;p&gt;formidable本身提供了一系列事件来处理文件上传操作，比如fileBegin，file，data，aborted，end等等，但这些事件还无法完全满足保存分段数据的一些特殊场景，比如网络中断或异常的情况下，需要将未上传完的文件保存下来，这可能是断点续传功能在实际应用场景的价值所在，应对这种场景则需使用更细化的接收事件onPart。&lt;/p&gt;
&lt;p&gt;在自定义onPart事件中，保存文件的核心方法使用了nodejs中的createWriteStream，使用flags:‘a’来保证没有文件时创建文件，有了文件时则往文件中添加内容。&lt;/p&gt;
&lt;p&gt;另外，在aborted调用end方法，确保网络异常的情况下，已上传的文件内容能被安全保存下来。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;form.onPart = part =&amp;gt; {
	const tempFilePath = `${tempFileDir}${part.filename}`
	const writer = fs.createWriteStream(tempFilePath, { flags: &amp;#39;a&amp;#39; })
	form.on(&amp;#39;aborted&amp;#39;, e =&amp;gt; {
	  writer.end()
	})

	form.on(&amp;#39;end&amp;#39;, () =&amp;gt; {
	  writer.end()
	})

	part.on(&amp;#39;data&amp;#39;, buffer =&amp;gt; {
	  writer.write(buffer)
	})
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;查询当前文件大小&lt;/h4&gt;
&lt;p&gt;上面前端部分提到过，续传前需要知道从哪里开始续传，具体做法就是用已上传的文件大小和整个文件大小做个除法来得知续传的开始点。nodejs中&lt;a href=&quot;https://nodejs.org/dist/latest-v12.x/docs/api/fs.html#fs_fs_stat_path_options_callback&quot;&gt;fs.statSync&lt;/a&gt;方法可以获取当前文件状态，通过size属性拿到当前文件的大小。&lt;/p&gt;
&lt;p&gt;然后将这些通过API开放给前端，使其能在续传前获取相关信息。&lt;/p&gt;

        &lt;deckgo-highlight-code language=&quot;javascript&quot; &gt;
          &lt;code slot=&quot;code&quot;&gt;router.get(&amp;#39;/get-tmp-file-size&amp;#39;, async ctx =&amp;gt; {
	const { name } = ctx.query
	const filePath = `./upload/tmp/${name}`
	try {
		const instance = fs.statSync(filePath)
		ctx.body = { size: instance.size }
	} catch (err) {
		ctx.body = { size: 0 }
	}
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;最后&lt;/h3&gt;
&lt;p&gt;总体而已，在我尝试编写demo的过程中，涉及的知识点渐渐超过了一开始的预期，每个点深挖下去都能牵扯出更多的内容，比如上传取消的功能，demo中我尝试用axois的CancelToken来实现，但使用后发现只能在文件上传前生效，一旦文件开始传输则无法取消，因此当前demo中的取消上传是通过最简单的刷新页面完成的。&lt;/p&gt;
&lt;p&gt;从面试的角度来说，这无疑是一个很好的题目，但假如工作中未接触或留意过上传相关的功能，在时间有限的情况下，其难度也是显而易见，在此祝每个面试中碰到此题的朋友们能有好运气。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;https://user-gold-cdn.xitu.io/2020/7/1/17308d9b3a7761ec?w=1702&amp;#x26;h=806&amp;#x26;f=png&amp;#x26;s=162909&quot;&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux系列之五 － 粘合剂react-redux组件（下）]]></title><description><![CDATA[react-redux组件是React和Redux两个框架的粘合剂，它共有两个部分：Provider组件和connect方法。上篇已介绍了Provider组件，本文就来详细讲解connect方法。 connect方法 在React…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20170401-redux-part-5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20170401-redux-part-5/</guid><pubDate>Sat, 01 Apr 2017 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;react-redux组件是React和Redux两个框架的粘合剂，它共有两个部分：Provider组件和connect方法。上篇已介绍了Provider组件，本文就来详细讲解connect方法。&lt;/p&gt;
&lt;h3&gt;connect方法&lt;/h3&gt;
&lt;p&gt;在&lt;a href=&quot;/20160328-react-part-7&quot;&gt;React系列之七&lt;/a&gt;中说到了一种设计模式－呈现组件和容器组件。简单来说，呈现组件只通过传入的属性负责呈现逻辑，而跟state相关的数据改动都放到容器组件中。connect方法就是为这种模式而生，它可以通过呈现组件快速生成容器组件。&lt;/p&gt;
&lt;p&gt;connect方法有4个参数，通常只会用到前两个，参数类型都是函数。假设现在已有一个呈现组件叫BookList, 那么connect的使用方法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function mapStateToProps(state) {
  return { todos: state.books}
}

function mapDispatchToProps(dispatch) {
  return { actions: bindActionCreators(actionCreators, dispatch) }
}

var container = connect(mapStateToProps, mapDispatchToProps)(BookList)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;从方法的名字mapStateToProps和mapDispatchToProps可以看出，connect的主要功能是以下两点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;从全局state中读取值，传递给呈现组件的props属性中。&lt;/li&gt;
&lt;li&gt;从让action creator和dispatch组合成简化的方法，传递给组件的props属性中。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这两点恰恰是容器组件要做的事，所以connect方法其实就是通过呈现组件快速生成容器组件的快捷方式。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于action creator和dispatch的组合可参考&lt;a href=&quot;/20170119-redux-part-3&quot;&gt;Redux系列之三&lt;/a&gt;中，对bindActionCreators的描述。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;用connect方法改造示例&lt;/h3&gt;
&lt;p&gt;这里我们用connect对&lt;a href=&quot;/20170119-react-part-2&quot;&gt;React系列文章之二&lt;/a&gt;中的例子做改造，该例中只有一个与颜色相关的下拉框，当用户选择后，state会保存选中的值。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/redux5-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;首先安装react-redux组件，命令如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install react-redux --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;而前文中说到redux将所有组件的state都存入了一个全局变量中，因此redux的重要作用之一就是容器组件的简单化。&lt;/p&gt;
&lt;p&gt;我们现在将下拉框中的state相关代码剥离出来，只留下呈现的逻辑，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// picker.js
import React, { PropTypes } from &amp;#39;react&amp;#39;

var Picker=({ value, onChange})=&amp;gt;{
  return(
    &amp;lt;div&amp;gt;
      &amp;lt;select onChange={e =&amp;gt; onChange(e.target.value)}
              value={value} &amp;gt;
        &amp;lt;option value=&amp;#39;&amp;#39;&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;#39;red&amp;#39;&amp;gt;red&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;#39;blue&amp;#39;&amp;gt;blue&amp;lt;/option&amp;gt;
      &amp;lt;/select&amp;gt;
      &amp;lt;p&amp;gt;selectedValue is: {value} &amp;lt;/p&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;代码中可以看出Picker组件接受2个属性值，没有state的操作，因为所有的state都保存在Redux中的Store里。修改Store的方法只有通过发送Action指令到Reducer中，首先，我们通过ActionCreator的方式来创建Action。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// actionCreator.js
function selectChangeCreator(value){
  return { type: &amp;#39;SELECTCHANGE&amp;#39;, value: value };
}

export default selectChangeCreator;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;现在创建一个名为selectChange的reducer，代码中需要注意的是，在’SELECTCHANGE’分支下，原state并没有做修改，而是新的state被创建并返回，不改变state状态，这是redux设计中的原则，否则会出现数据更新，组件不更新的情况。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// reducer.js
export function selectChange(state={selectedValue:&amp;#39;&amp;#39;}, action){
  switch (action.type) {
    case &amp;#39;SELECTCHANGE&amp;#39;:
      var newState = Object.assign({},
        ...state,
        {
          selectedValue: action.value
        })

      return newState;
    default:
      return state;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;关于不更新state的原则，可在&lt;a href=&quot;http://redux.js.org/docs/Troubleshooting.html&quot;&gt;官网此处&lt;/a&gt;查询
创建newState用到的”Object.assign”和扩展字符串 “…state”,可在阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ES6入门中&lt;/a&gt;查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;通过connect方法创建容器组件&lt;/h4&gt;
&lt;p&gt;准备工作都完成以后，现在我们就可以通过connect方法来创建容器组件了。首先，创建一个组件将上文所写的Picker组件包含进去，并将对应的属性值赋值给Picker组件。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import Picker from &amp;#39;./picker&amp;#39;

class Container extends Component{
  render(){
    var {value, onChange}= this.props;
    return(
    &amp;lt;div&amp;gt;
      &amp;lt;Picker value={value} onChange={onChange} /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;代码中可以看到，value值和onChange方法都是从自身到props属性取出，它们就是通过connect方法生成的，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function mapStateToProps(state){
  var { selectChange }= state
  return {
    value: selectChange.selectedValue
  }
}

function mapDispatchToProps(dispatch){
  var boundActionCreator=bindActionCreators(actionCreator, dispatch);
  return {
    onChange:(value)=&amp;gt;{
       boundActionCreator(value)
     }
  }
}

var PickerContainer = connect(
  mapStateToProps,
  mapDispatchToProps)(Container)

export default PickerContainer&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;代码中可以看到，mapStateToProps方法将state.selectChange.selectedValue赋值给了value。mapDispatchToProps将dispatch和actionCreator绑定后的方法赋值给了onChange，最后生成PickerContainer组件并返回。&lt;/p&gt;
&lt;p&gt;现在只需要在入口文件(index.js)中引用此组件就可以了。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// index.js
import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;
import { combineReducers, createStore} from &amp;#39;redux&amp;#39;
import { Provider } from &amp;#39;react-redux&amp;#39;
import { selectChange } from &amp;#39;./reducer&amp;#39;
import PickerContainer from &amp;#39;./container.js&amp;#39;

var reducers= combineReducers({selectChange})

var store = createStore(reducers)

ReactDOM.render(
  &amp;lt;Provider store={store}&amp;gt;
    &amp;lt;PickerContainer /&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById(&amp;#39;demo5&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;记得connect需要和Provider组件配合使用，因此PickerContainer必须被包裹在Provider中。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于Provider的使用说明可参考&lt;a href=&quot;/20170302-redux-part-4&quot;&gt;上篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;react-redux组件的connect方法是通过呈现组件创建容器组件的一种快捷方式，它需要和Provider组件一起使用。&lt;/p&gt;
&lt;p&gt;本文相关的代码可在&lt;a href=&quot;https://github.com/twomeetings/reduxExample&quot;&gt;示例代码&lt;/a&gt;中的目录demo5中找到。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux系列之四 － 粘合剂react-redux组件（上）]]></title><description><![CDATA[前三篇介绍了redux的用法，虽然示例代码中使用了react框架来呈现数据，但实际上两者之间并未有太多交集，而且为了结合redux框架，react的写法也不得不调整，反而造成了不便。这个问题产生的原因是少用了一个核心组件react-redux，它是react和redux…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20170302-redux-part-4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20170302-redux-part-4/</guid><pubDate>Thu, 02 Mar 2017 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;前三篇介绍了redux的用法，虽然示例代码中使用了react框架来呈现数据，但实际上两者之间并未有太多交集，而且为了结合redux框架，react的写法也不得不调整，反而造成了不便。这个问题产生的原因是少用了一个核心组件react-redux，它是react和redux框架的粘合剂。&lt;/p&gt;
&lt;p&gt;react-redux组件的用法很简单，只有两个部分：一个是Provider组件，另一个是connect方法，本文重点讲解Provider组件。&lt;/p&gt;
&lt;h3&gt;Provider组件&lt;/h3&gt;
&lt;p&gt;在前三篇的示例中，示例代码中使用了自定义的Counter组件，可这种组件是呈现组件，没有state相关的逻辑。然而有时，组件需要在内部操作state，无法通过props属性暴露给调用方，这就需要在redux框架下编写容器组件。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;关于呈现组件和容器组件的概念可参考&lt;a href=&quot;/20160316-react-part-6&quot;&gt;React系列文章之六&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;由于redux将所有组件的state都存放在全局变量Store中，因此，在Rudux框架下的容器组件写法也略有不同，需要将Store通过属性props来传入。&lt;/p&gt;
&lt;p&gt;在&lt;a href=&quot;/20160316-react-part-6&quot;&gt;React系列之二&lt;/a&gt;的示例中有一个下拉框，通过state保存用户对颜色的选择，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var Picker= React.createClass({
  getInitialState(){
    return {selectedColor:&amp;#39;&amp;#39;}
  },
  render(){
    var color= this.state.selectedColor;
    return(
      &amp;lt;div&amp;gt;
        &amp;lt;select onChange={this._handleChange}&amp;gt;
          &amp;lt;option value=&amp;#39;&amp;#39;&amp;gt;&amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;red&amp;#39;&amp;gt;Red&amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;blue&amp;#39;&amp;gt;Blue &amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;green&amp;#39;&amp;gt;Green &amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
        &amp;lt;p&amp;gt;selected color is : {color} &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  },
  _handleChange(event){
    this.setState({selectedColor: event.target.value});
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;Store可以通过props传入到容器组件内，但是组件有时还会包含子组件，一旦层级过深，传递Store的写法会变的难以维护。因此，react-redux组件提供了一个方法，只需在外侧用Provider组件包裹住，就可以将store传递下去，写法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import ReactDOM from &amp;#39;react-dom&amp;#39;
import {Provider} from &amp;#39;react-redux&amp;#39;
import { createStore} from &amp;#39;redux&amp;#39;
import Picker from &amp;#39;./picker&amp;#39;
import Reducer from &amp;#39;./reducer&amp;#39;

const store = createStore(Reducer)
ReactDOM.render(
  &amp;lt;Provider store={store}&amp;gt;
    &amp;lt;Picker /&amp;gt;
  &amp;lt;/Provider&amp;gt;,
  document.getElementById(&amp;#39;demo4&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;被Provider组件包裹后，内部的所有组件都可以通过this.context.store访问到全局变量Store，上面的Picker组件的render方法改动如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;  render(){
    var { store }= this.context;
    return(
      &amp;lt;select value={store.getState().selectedValue} onChange={this._handleChange.bind(this)}&amp;gt;
        &amp;lt;option value=&amp;#39;&amp;#39;&amp;gt;&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;#39;red&amp;#39;&amp;gt;Red&amp;lt;/option&amp;gt;
        &amp;lt;option value=&amp;#39;blue&amp;#39;&amp;gt;Blue&amp;lt;/option&amp;gt;
      &amp;lt;/select&amp;gt;
    )
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;当需要发送Action指令来改变state状态时，可以直接调用store的实例，执行dispatch方法。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;_handleChange(event){
    var { store }= this.context;
    store.dispatch({type:&amp;#39;SELECTCHANGE&amp;#39;, value: event.target.value})
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;注意&lt;/h3&gt;
&lt;p&gt;想要在组件中通过this.context.store读取到值，除了将其包裹在Provider组件中之外，还要添加一个属性contextTypes，在本例中，写法如下。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;Picker.contextTypes = { store: React.PropTypes.object };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;Provider很少单独使用，当Provider和connect方法一起使用时，则不必添加contextTypes。&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;在Redux架构下，必需将全局变量Store传入组件内部，才能操作state，当组件内嵌的子组件层数过多时，这种写法难以维护。通过react-redux提供的Provider组件包裹的方式，将Store传入各个组件中。&lt;/p&gt;
&lt;p&gt;本系列示例可在&lt;a href=&quot;https://github.com/twomeetings/reduxExample&quot;&gt;此处下载&lt;/a&gt;，本文的代码可在目录demo4中查询。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux系列之三－Action的简化：bindActionCreator方法]]></title><description><![CDATA[Action和Action Creator Action是Redux中的核心概念之一，它是信息的载体包含跟操作指令相关的信息，因此它是一个必需包含type属性的对象，type表示我们自定义的指令类别。 发送指令需调用Store的方法dispatch…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20170119-redux-part-3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20170119-redux-part-3/</guid><pubDate>Thu, 19 Jan 2017 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Action和Action Creator&lt;/h3&gt;
&lt;p&gt;Action是Redux中的核心概念之一，它是信息的载体包含跟操作指令相关的信息，因此它是一个必需包含type属性的对象，type表示我们自定义的指令类别。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
	type: &amp;#39;SOMETHING&amp;#39;,
	//...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;发送指令需调用Store的方法dispatch，比如在&lt;a href=&quot;/20161104-redux-part-2&quot;&gt;前文&lt;/a&gt;的示例中，三个Counter组件通过dispatch分别发生了不同类别的指令：INCREMENT, OTHER&lt;em&gt;INCREMENT, DOUBLE&lt;/em&gt;INCREMENT。相关代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;		&amp;lt;Counter
        value = {state.counterReducer.value}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;INCREMENT&amp;#39;})}
      /&amp;gt;
      &amp;lt;Counter
        value = {state.counterReducer.otherValue}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;OTHER_INCREMENT&amp;#39;})}
      /&amp;gt;
      &amp;lt;Counter
        value = {state.secondReducer.value}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;DOUBLE_INCREMENT&amp;#39;})}
      /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;有时，action会包含一些逻辑，因此，在redux中，通常会用一个方法来创建action，这样的方法叫‘action creator’。比如，创建INCREMENT类别的action，可创建一个increment方法，写法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function incremment(){
  return {
    type: &amp;#39;INCREMENT&amp;#39;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;简化Action指令的发送&lt;/h3&gt;
&lt;p&gt;上节看似多此一举的写法，实际上给redux带来了很多扩展性和便利。redux中发送action总需要调用Store的dispatch方法，如下。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;()=&amp;gt; store.dispatch({type:&amp;#39;INCREMENT&amp;#39;})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;redux提供了bindActionCreator方法，可以将action和dispatch结合在一起，达到简化写法的目的。&lt;/p&gt;
&lt;p&gt;现在我们创建一个action.js，添加三个方法用于创建那三个组件需要的action。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;export function incremment(){
  return {
    type: &amp;#39;INCREMENT&amp;#39;
  }
}

export function otherIncremment(){
  return {
    type: &amp;#39;OTHER_INCREMENT&amp;#39;
  }
}

export function doubleIncremment(){
  return {
    type: &amp;#39;DOUBLE_INCREMENT&amp;#39;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;在入口文件(index.js)中，我们引入并调用bindActionCreator，将其与dispatch合并。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;mport {createStore, combineReducers, bindActionCreators} from &amp;#39;redux&amp;#39;
import {counterReducer, secondReducer} from &amp;#39;./reducer.js&amp;#39;
import * as actionCreators from &amp;#39;./action.js&amp;#39;

var reducers=combineReducers({counterReducer,secondReducer})

const store = createStore(reducers)

var boundActionCreators = bindActionCreators(actionCreators, store.dispatch)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;此处import * as actionCreators，是引入模块的一种写法，作用是将模块中所有导出的部分引入并命名为一个变量，import命令的详细信息可参考阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ES6入门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;绑定后的boundActionCreators对象结构如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
	incremment: function(){/.../},
	otherIncremment: function(){/.../},
	doubleIncremment: function(){/.../}
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;通过bindActionCreator方法的绑定，每次发送Action指令时，就不必再添加调用dispatch方法，或者说通过绑定，dispatch方法会自动被调用。因此入口文件(index.js)的组件呈现部分，就可以改动如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;ReactDOM.render(
    &amp;lt;div&amp;gt;
      &amp;lt;Counter
        value = {state.counterReducer.value}
        handleClick={boundActionCreators.incremment}
      /&amp;gt;
      &amp;lt;Counter
        value = {state.counterReducer.otherValue}
        handleClick={boundActionCreators.otherIncremment}
      /&amp;gt;
      &amp;lt;Counter
        value = {state.secondReducer.value}
        handleClick={boundActionCreators.doubleIncremment}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
    ,
    document.getElementById(&amp;#39;demo3&amp;#39;)
  )&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;Action是Redux中的核心组件，承载着指令相关的信息，创建Action的方法有两种，直接手写和通过方法返回，而redux推荐后一种方法，并且提供了bindActionCreator方法来简化Action指令发送相关的代码。&lt;/p&gt;
&lt;p&gt;示例代码可以在&lt;a href=&quot;https://github.com/twomeetings/reduxExample&quot;&gt;此处下载&lt;/a&gt;，本文相关的代码可在目录demo3中寻找。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux系列之二－Reducer的合并：combineReducers方法]]></title><description><![CDATA[前文的示例代码包含一个reducer，逻辑是state数值加1。那么当多个reducer存在时，redux是怎样在一个全局对象中管理状态的呢？现在，我们扩展例子，再添加一个Counter组件，并让两个Counter的值各自独立，相互不受影响。 代码中可以看到，第二个Counter…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20161104-redux-part-2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20161104-redux-part-2/</guid><pubDate>Fri, 04 Nov 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;前文的示例代码包含一个reducer，逻辑是state数值加1。那么当多个reducer存在时，redux是怎样在一个全局对象中管理状态的呢？现在，我们扩展例子，再添加一个Counter组件，并让两个Counter的值各自独立，相互不受影响。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// index.js
  ReactDOM.render(
    &amp;lt;div&amp;gt;
      &amp;lt;Counter
        value = {store.getState()}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;INCREMENT&amp;#39;})}
      /&amp;gt;
      &amp;lt;Counter
        value = {store.getState()}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;OTHER_INCREMENT&amp;#39;})}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
    ,
    document.getElementById(&amp;#39;demo2&amp;#39;)
  )
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;代码中可以看到，第二个Counter组件点击时，发送的Action类型和第一个不同，因为redux的机制，对Action多逻辑处理都放在在了Reducer中。在之前的reducer.js文件中，只有一个方法counterReducer，并且通过ES6语法将全局state初始化成了数值0，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function counterReducer(state = 0, action){
  // ...
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;关于ES6中对方法参数的初始化写法，可参考阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ES6入门&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;记录多个值需要用到对象或数组，而常见的写法是将全局state当作对象，因此原方法counterReducer的逻辑需做修改，用state对象的value属性来记录数值。对于第二个组件，用otherValue属性来记录对应的值，这样可以保证两个组件不会冲突，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function counterReducer(state = { value:0, otherValue:0 }, action){
  state.value =  state.value || 0;
  switch (action.type) {
    case &amp;#39;INCREMENT&amp;#39;:
      state.value++;
      return state;
    case &amp;#39;OTHER_INCREMENT&amp;#39;:
      state.otherValue++;
      return state;
    default:
      return state;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;此时的全局变量state结构如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
	value:0,
	otherValue:0
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;编译后页面如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/redux2-1&quot;&gt;&lt;/p&gt;
&lt;h3&gt;conbineReducers－解决属性冲突&lt;/h3&gt;
&lt;p&gt;在同一个reducer中，修改属性名比较容易，比如上文中，我们用不同的属性名value和otherValue避免组件的冲突。但是，项目中通常存在多个组件，这些组件相关的reducer写在不同的方法中，这种情况容易出现属性名冲突，且难以修改。比如，现在我们再引入第三个Counter组件，且该组件对应另一个reducer方法，也同样用value属性名来保存值，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// reducer.js
export function counterReducer(state = { value:0, otherValue:0}, action){
  state.value =  state.value || 0;
  switch (action.type) {
    case &amp;#39;INCREMENT&amp;#39;:
      state.value++;
      return state;
    case &amp;#39;OTHER_INCREMENT&amp;#39;:
      state.otherValue++;
      return state;
    default:
      return state;
  }
}

export function secondReducer(state={ value:0 }, action){
  switch (action.type) {
    case &amp;#39;DOUBLE_INCREMENT&amp;#39;:
      state.value= state.value+2;
      return state;
    default:
      return state;
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;redux提供了conbineReducers方法来应对多个reducer合并成一个，从而解决属性名冲突的情况，用法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import {createStore, combineReducers} from &amp;#39;redux&amp;#39;
import {counterReducer, secondReducer} from &amp;#39;./reducer.js&amp;#39;

var reducers=combineReducers({counterReducer,secondReducer})

const store = createStore(reducers)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;conbineReducers在全局对象中添加了与方法名对应的属性，通过这种方法解决了冲突问题。此时全局对象state的解构如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
	counterReducer: { value:0, otherValue:0},
	secondReducer: { value:0 }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;在这种情况下，组件初始化时传入的值也要加方法前缀，比如state.counterReducer.value。因此引用组件的入口文件index.js也要做相应调整，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;ReactDOM.render(
    &amp;lt;div&amp;gt;
      &amp;lt;Counter
        value = {state.counterReducer.value}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;INCREMENT&amp;#39;})}
      /&amp;gt;
      &amp;lt;Counter
        value = {state.counterReducer.otherValue}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;OTHER_INCREMENT&amp;#39;})}
      /&amp;gt;
      &amp;lt;Counter
        value = {state.secondReducer.value}
        handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;DOUBLE_INCREMENT&amp;#39;})}
      /&amp;gt;
    &amp;lt;/div&amp;gt;
    ,
    document.getElementById(&amp;#39;demo2&amp;#39;)
  )&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;本文详细解释了当所有组件的state都放在一个全局变量时不可避免的属性名冲突问题，以及如何通过redux提供的conbineReducers方法解决此问题。&lt;/p&gt;
&lt;p&gt;代码示例可在&lt;a href=&quot;https://github.com/twomeetings/reduxExample&quot;&gt;此处下载&lt;/a&gt;，在目录demo2中可找到本文示例。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Redux系列之一－开篇]]></title><description><![CDATA[Redux是什么？ React的开发需要配合一种前端框架来组织代码，使得项目能易于维护和扩展。大家熟知的前端框架就是MVC，然而facebook的开发人员在尝试了React＋MVC模式之后，发现其并不适合开发大型应用，便采用了一种新的前端架构，叫Flux。 但其实，Flux…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160612-redux-part-1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160612-redux-part-1/</guid><pubDate>Sun, 12 Jun 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;Redux是什么？&lt;/h3&gt;
&lt;p&gt;React的开发需要配合一种前端框架来组织代码，使得项目能易于维护和扩展。大家熟知的前端框架就是MVC，然而facebook的开发人员在尝试了React＋MVC模式之后，发现其并不适合开发大型应用，便采用了一种新的前端架构，叫Flux。&lt;/p&gt;
&lt;p&gt;但其实，Flux本身是一种架构思想，除了官方点Flux框架外，开源社区围绕这个架构思想开发了很多相似的框架，Redux就是其中一个，而且是目前人气最高的一个。&lt;/p&gt;
&lt;h3&gt;Flux和MVC的对比&lt;/h3&gt;
&lt;p&gt;关于弃用MVC，Facebook官方给出了一个案例，在facebook页面上存在两个View，一个是消息列表，一个是未读消息气泡，每次有新的消息进来时，除需更新消息列表的Model之外，还要处理未读消息数的Model，这导致了数据更新之间的联动，看似独立的View和Model之间存在了依赖。因此在逻辑复杂的大项目中，更新联动就让调试和维护变的困难，facebook将这个问题归结为MVC架构的数据双向绑定，并给出了下图。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/redux1-1.png&quot;&gt;&lt;/p&gt;
&lt;p&gt;针对双向绑定的问题，Flux就应运而生了，这种框架包含4个部分，如果与MVC相对照的看，Model变成成了Store，Controller变成了Dispatcher和Action，View依然是View。除了各个概念与MVC有略微差异外，Flux最大的特点就是数据的单向流动，极大的提高了逻辑的可预测性，从而让架构变的简洁，易于维护。&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/redux1-2.png&quot;&gt;&lt;/p&gt;
&lt;h3&gt;简易示例&lt;/h3&gt;
&lt;p&gt;现在让我们用redux创建一个实例，比官方示例更加简单的计数器，内容是点击一下按钮，对应的数值加1。示例的框架使用了webpack＋react＋redux的形势，如果对webpack和react不熟悉，则可以先阅读我之前所写的&lt;a href=&quot;/20150712-react-part-1&quot;&gt;react系列文章&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;搭建好项目，安装好webpack和react的相关的安装包后，要记得安装redux，命令如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install redux --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;View－呈现数据&lt;/h3&gt;
&lt;p&gt;首先我们创建一个Counter类（counter.js），用于数据呈现：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { Component, PropTypes } from &amp;#39;react&amp;#39;

class Counter extends Component{
  render(){
    var { value, handleClick} = this.props;
    return(
      &amp;lt;div&amp;gt;
        Clicked: {value} times
        &amp;lt;p&amp;gt;
          &amp;lt;button onClick={handleClick} &amp;gt;Button&amp;lt;/button&amp;gt;
        &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
}

Counter.propTypes={
  value:PropTypes.number.isRequired,
  handleClick: PropTypes.func.isRequired
}

export default Counter&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;Counter类的呈现逻辑中，需要用到两个属性值value和handleClick，一个是数值，一个是方法，并且用PropTypes对这两个属性做了必填的限制。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;Counter.propTypes={
  value:PropTypes.number.isRequired,
  handleClick: PropTypes.func.isRequired
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;Action－数据载体&lt;/h3&gt;
&lt;p&gt;在Flux框架中，处理逻辑的部分（即MVC中的Controller）被分成了两块Action和Dispatcher。&lt;/p&gt;
&lt;p&gt;Action时执行操作所需的数据载体，相当于传入的参数。它是一个对象，该对象必须包含一个type属性，type属性表示类型，方便dispather识别。本例中的action对象如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{ type:&amp;#39;INCREMENT&amp;#39; }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;常见的写法中，action对象不会直接编写，而是通过一个方法返回，这种方法就叫“action creator”，本例中假如采用action creator的写法会是下面这样：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function AddCounter(){
  return { type: &amp;#39;INCREMENT&amp;#39;}
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这看似多余的一步，却可以给action带来极大的扩展性，这在后文会提及。&lt;/p&gt;
&lt;h3&gt;Dispatcher－(Reducer)逻辑处理&lt;/h3&gt;
&lt;p&gt;Dispatcher的作用是则是针对不同的Action做相应的逻辑处理，最终在组件的state上做相应的修改，所以Dispatcher常常是一个方法。本例中的Dispatcher创建在reducer.js文件中，内容如下。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;function counterReducer(state = 0, action){
  switch (action.type) {
    case &amp;#39;INCREMENT&amp;#39;:
      return state + 1;
    default:
      return state;
  }
}

export default counterReducer;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;因为Dispatcher是根据action来操作state，所以它的常规写法是一个包含了两个参数的函数，一个是state，一个是action。
本例中，当Dispather的逻辑是，当收到类型为INCREMENT的action时，将state加1。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;在Redux中，Dispatcher又叫Reducer，这是因为它的核心方法是javascript中数组的reduce方法，故以Reducer来命名，该方法详情可查看&lt;a href=&quot;https://msdn.microsoft.com/zh-cn/library/ff679975(v=vs.94).aspx&quot;&gt;此站点&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;Store－数据保存&lt;/h3&gt;
&lt;p&gt;在Redux中，数据持久化的方式是所有的state数据都保存在一个全局对象中，这个对象就是Store。在redux中创建Store对象非常简单，利用模块方法createStore即可。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import {createStore} from &amp;#39;redux&amp;#39;
import Reducer from &amp;#39;./reducer.js&amp;#39;

const store = createStore(Reducer)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可以看到createstore方法的参数是我们上节中定义的Reducer(即Dispatcher)，所以Dispather和Store是挂靠在一起的。&lt;/p&gt;
&lt;p&gt;当有action传入时，Store会依次遍历自身所有的Reducer，根据type做相应处理，并将修改后的值保存在全局state对象中。&lt;/p&gt;
&lt;p&gt;Store对象有三个方法，就是用来完成上述工作：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;getState。－获取当前state。&lt;/li&gt;
&lt;li&gt;dispatch。 －接收并处理action&lt;/li&gt;
&lt;li&gt;subscribe。 －订阅事件，当state更新时，刷新对应的组件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;本例中与Store这三个方法的相关代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;
import {createStore} from &amp;#39;redux&amp;#39;

import Counter from &amp;#39;./counter.js&amp;#39;
import Reducer from &amp;#39;./reducer.js&amp;#39;

const store = createStore(Reducer)

function customRender(){
  ReactDOM.render(
    &amp;lt;Counter
      value = {store.getState()}
      handleClick={()=&amp;gt; store.dispatch({type:&amp;#39;INCREMENT&amp;#39;})}
    /&amp;gt;,
    document.getElementById(&amp;#39;demo1&amp;#39;)
  )
}

customRender()
store.subscribe(customRender)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;本系列的示例代码可在&lt;a href=&quot;https://github.com/twomeetings/reduxExample&quot;&gt;此处&lt;/a&gt;下载，本文代码在目录demo1中。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React系列之八－组件的生命周期]]></title><description><![CDATA[在系列文章第三篇中，我们谈到了组件的事件，但只提到了其中两个事件方法，其实react组件的事件方法并不多，总共只有7个，如下： 所有的这些事件拼成了react组件的生命周期，那么，在整个生命周期中，这些事件的顺序是怎样的？本文中，我创建一个示例，通过在每个事件中用console…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160406-react-part-8/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160406-react-part-8/</guid><pubDate>Wed, 06 Apr 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在&lt;a href=&quot;/20151108-react-part-3&quot;&gt;系列文章第三篇&lt;/a&gt;中，我们谈到了组件的事件，但只提到了其中两个事件方法，其实react组件的事件方法并不多，总共只有7个，如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;componentWillMount
componentDidMount
componentWillReceiveProps
shouldComponentUpdate
componentWillUpdate
componentDidUpdate
componentWillUnmount&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;所有的这些事件拼成了react组件的生命周期，那么，在整个生命周期中，这些事件的顺序是怎样的？本文中，我创建一个示例，通过在每个事件中用console.log输出信息到控制台，来查看执行顺序，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;componentWillMount(){
    console.log(&amp;#39;componentWillMount&amp;#39;);
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后创建一个类似&lt;a href=&quot;/20150721-react-part-2&quot;&gt;系列文章第二篇&lt;/a&gt;中的组件，可以通过选中下拉框，来改变组件本身的state，这也就可以观察到组件初始化时和状态改变时，两种状态下的生命周期。现在，创建index.js，基本代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { Component } from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

class SimpleComponent extends Component{
  constructor() {
    super()
    this.state={selectedValue: &amp;#39;&amp;#39; }
  }

  _handleChange(event){
    this.setState({selectedValue: event.target.value})
  }

  render(){
  	console.log(&amp;#39;render&amp;#39;)
    return(
      &amp;lt;div&amp;gt;
        &amp;lt;select onChange={this._handleChange.bind(this)} &amp;gt;
          &amp;lt;option value=&amp;#39;&amp;#39;&amp;gt;&amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;nodejs&amp;#39;&amp;gt;nodejs&amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;react&amp;#39;&amp;gt;react&amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
        &amp;lt;p&amp;gt;selected value is : {this.state.selectedValue}&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }
  
  /.../
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;这里为了让代码简洁，为省略了只有console.log的7个事件方法，详情可在代码示例中查看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;编译后页面如图所示：
&lt;code&gt;图片&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现在，我们观察浏览器控制台，当页面初始化时，我们得到信息如下，可以看到加上render方法，只有3个事件方法被触发：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;componentWillMount
render
componentDidMount&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后，选中下拉框来修改组件state状态，得到如下信息：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;shouldComponentUpdate
componentWillUpdate
render
componentDidUpdate&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;复杂组件的生命周期&lt;/h3&gt;
&lt;p&gt;从上文到演示中可以看到单个组件初始化和状态改变时的生命周期，但奇怪的是，7个生命周期事件中，只有5个被触发，另外两个在什么情况下才会触发呢？&lt;/p&gt;
&lt;p&gt;现在我们将组件设计的复杂一些，结合&lt;a href=&quot;/20160328-react-part-7&quot;&gt;系列文章第七篇&lt;/a&gt;中的容器组件和呈现组件的例子，当用户选择了下拉框之后，根据选中内容请求豆瓣图书API获取图书，再将书名呈现出来。在这样的情况下，我们观察一下容器组件和呈现组件的生命周期会是怎样的。&lt;/p&gt;
&lt;p&gt;页面呈现如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/React8-1&quot;&gt;&lt;/p&gt;
&lt;p&gt;现在，我们用蓝色表示容器组件的生命周期，绿色组件表示呈现组件的生命周期。初始化时，控制台信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/React8-2&quot;&gt;&lt;/p&gt;
&lt;p&gt;选择下拉框，改变状态以后，控制台信息如下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/React8-3&quot;&gt;&lt;/p&gt;
&lt;h3&gt;结语&lt;/h3&gt;
&lt;p&gt;本文代码可在&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;示例代码&lt;/a&gt;中的demo8目录中查询。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React系列之七－组件间的通信－呈现组件和容器组件]]></title><description><![CDATA[在React中有一种常用的的设计模式，就是将组件分为呈现组件(presentatial component)和容器组件(container component),它们和MVC框架概念中的V和C…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160328-react-part-7/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160328-react-part-7/</guid><pubDate>Mon, 28 Mar 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;在React中有一种常用的的设计模式，就是将组件分为呈现组件(presentatial component)和容器组件(container component),它们和MVC框架概念中的V和C很相似，呈现组件只负责呈现数据，而容器组件负责逻辑的处理。&lt;/p&gt;
&lt;p&gt;现在我们创建一个示例，像&lt;a href=&quot;/20151108-react-part-3&quot;&gt;系列文章第三篇&lt;/a&gt;的例子那样调用豆瓣图书API获取信息，然后将信息呈现在页面上。首先，我们将所有逻辑写在一起，创建index.js，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { Component} from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

class BookListContainer extends Component{
  constructor() {
    super()
    this.state={ books:[] }
  }

  componentDidMount(){
    var url=&amp;quot;https://api.douban.com/v2/book/search?q=nodejs&amp;quot;;
    $.ajax({
      type: &amp;quot;GET&amp;quot;,
      dataType: &amp;#39;jsonp&amp;#39;,
      url:url
    }).done(function(result){
      this.setState({books:result.books})
    }.bind(this))
  }

  render(){
    return(
      &amp;lt;ul&amp;gt;
        {this.state.books.map(e=&amp;gt;&amp;lt;li key={e.id}&amp;gt;{e.title}&amp;lt;/li&amp;gt;)}
      &amp;lt;/ul&amp;gt;
    )
  }
}

ReactDOM.render(
  &amp;lt;BookListContainer /&amp;gt;,
  document.getElementById(&amp;#39;demo7&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;编译后，呈现页面如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;页面图片&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;代码解析&lt;/h2&gt;
&lt;p&gt;BookListContainer组件的作用是，在组件初始化完毕后，异步请求豆瓣图书API，以nodejs为关键字，搜索相关图书，并最后用html标签将数据呈现在页面上。&lt;/p&gt;
&lt;p&gt;如果按照功能划分的话，BookListContainer组件只做了两件事：获取数据和呈现数据。两种功能放在同一个组件会导致组件的复用性受到限制，因此，我们现在按照设计模式，将BookListContainer组件中呈现数据的部分抽离出来，作为一个单独的组件，叫BookListPresentation，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;class BookListPresentation extends Component {
  render(){
      var books = this.props.books;
      return (
        &amp;lt;ul&amp;gt;
          {books.map(e=&amp;gt;&amp;lt;li key={e.id}&amp;gt;{e.title}&amp;lt;/li&amp;gt;)}
        &amp;lt;/ul&amp;gt;
      )
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;因此BookListContainer对render方法就不必再负责呈现逻辑，直接使用BookListPresentation组件：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;render(){
    return(
      &amp;lt;BookListPresentation books={this.state.books} /&amp;gt;
    )
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这样做可以让呈现组件能复用在其他地方，假如呈现逻辑改变了，直接替换掉呈现组件就可以了，这也一定程度上保证了容器组件的复用。&lt;/p&gt;
&lt;p&gt;而且，由于将呈现逻辑抽离，呈现组件内部不需要用到state或其他复杂的功能，正好适用&lt;a href=&quot;/20160316-react-part-6&quot;&gt;前文提过的stateless写法&lt;/a&gt;，从而进一步减少代码量，提高效率。比如此处BookListPresentation可改写为如下内容：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var BookListPresentation = ({ books })=&amp;gt;
    &amp;lt;ul&amp;gt;
      {books.map(e=&amp;gt;&amp;lt;li key={e.id}&amp;gt;{e.title}&amp;lt;/li&amp;gt;)}
    &amp;lt;/ul&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;结语&lt;/h4&gt;
&lt;p&gt;将组件中的呈现逻辑和数据业务逻辑分离开来，可以很大程度上提高组件的复用性，而且让不需要复杂功能的呈现组件可以充分利用react特性和ES6语法糖减少代码量，提高效率。&lt;/p&gt;
&lt;p&gt;本文的示例可在&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;示例代码&lt;/a&gt;的demo7目录中查阅。&lt;/p&gt;
&lt;h4&gt;参考链接&lt;/h4&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@learnreact/container-componentsc0e67432e005#.jww2ntlwh&quot;&gt;https://medium.com/@learnreact/container-componentsc0e67432e005#.jww2ntlwh&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.ehf25rep4&quot;&gt;https://medium.com/@dan_abramov/smart-and-dumb-components-7ca2f9a7c7d0#.ehf25rep4&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[React系列之六－stateless组件的写法]]></title><description><![CDATA[函数就是stateless组件 前文介绍了编写react组件的两种写法，React写法和ES6写法，除此之外还有一种编写组件的写法，而这种写法编写的组件会略有不同，这样的组件叫stateless组件。顾名思义，stateless…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160316-react-part-6/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160316-react-part-6/</guid><pubDate>Wed, 16 Mar 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;函数就是stateless组件&lt;/h3&gt;
&lt;p&gt;前文介绍了编写react组件的两种写法，React写法和ES6写法，除此之外还有一种编写组件的写法，而这种写法编写的组件会略有不同，这样的组件叫stateless组件。顾名思义，stateless组件就是没有状态的组件，这种组件的写法基本等同于javascript的函数，函数的参数就是组件的props属性。&lt;/p&gt;
&lt;p&gt;现在我们用这种写法重写&lt;a href=&quot;/20150712-react-part-1&quot;&gt;系列文章第一篇&lt;/a&gt;的示例，添加index.js文件，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

function HelloMessage(props){
  return (&amp;lt;div&amp;gt;Hello {props.name}, {props.year}!&amp;lt;/div&amp;gt;)
}

ReactDOM.render(
  &amp;lt;HelloMessage name=&amp;quot;Jacky&amp;quot; year=&amp;#39;2016&amp;#39;/&amp;gt;,
  document.getElementById(&amp;#39;demo6&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;代码中可以看到，HelloMessage组件就是函数HelloMessage，函数的返回值就是组件要呈现的内容，等同于组件的render方法。与返回值与以往函数的区别是：字符串作为其返回值不是用引号包裹，而是括号。&lt;/p&gt;
&lt;p&gt;函数的参数就是组件的props，而这种组件不支持state，这也是组件名称的由来。除此之外，这种组件不支持ref属性，没有组件生命周期相关的事件方法，但支持propTypes，写法和&lt;a href=&quot;/20160301-react-part-5&quot;&gt;ES6组件写法&lt;/a&gt;)一样。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;HelloMessage.propType = { name: Proptypes.string.isRequired}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;因此，这种组件的作用就是用来简单的呈现数据，最大的特点就是编写方便。&lt;/p&gt;
&lt;h3&gt;箭头函数&lt;/h3&gt;
&lt;p&gt;在ES6的语法里，函数可以有一种写法叫箭头函数，比如上面的HelloMessage组件箭头函数编写后，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var HelloMessage=(props)=&amp;gt;{
  return (&amp;lt;div&amp;gt;Hello {props.name}, {props.year}!&amp;lt;/div&amp;gt;)
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;而且箭头函数可以进一步简化：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var HelloMessage=(props)=&amp;gt; &amp;lt;div&amp;gt;Hello {props.name}, {props.year}!&amp;lt;/div&amp;gt;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可以看到stateless组件的写法是三种写法里最简洁的。&lt;/p&gt;
&lt;h3&gt;解构赋值&lt;/h3&gt;
&lt;p&gt;解构是ES6的新赋值语法，变量可以通过解构赋值，简单来说就是可以从对象中抽取值给变量。像下面代码这样，变量a和b可以直接从obj对象中提取属性值，前者等于name，后者等于year。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var obj={name: &amp;#39;jacky&amp;#39;, year:2016 }
 var {name:a, year:b} = obj;
 console.log(a); // jacky
 console.log(b); // 2016&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;通过解构给变量赋值，需要被包裹在花括号内。且当变量名和对象的属性名一样时，语法可以进一步简化，如下，变量name和year直接就被赋了obj的属性name和year的值：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var obj={name: &amp;#39;jacky&amp;#39;, year:2016 }
var {name, year} = obj;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;解构也可以用在数组，关于解构的详细的说明可以在阮一峰老师的文章：&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/destructuring&quot;&gt;ECMAScript6入门&lt;/a&gt;里查看。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;当解构和箭头函数组合在一起时，我们的stateless组件的写法可以做进一步的改变：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var HelloMessage=({name, year})=&amp;gt; &amp;lt;div&amp;gt;Hello {name}, {year}!&amp;lt;/div&amp;gt;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可以看到解构赋值直接用在了函数的第一个参数，props的name和year属性被赋给了name和year变量。&lt;/p&gt;
&lt;p&gt;注意，这种简化的解构写法中，变量名一定要和对象对属性名一致，而正常的函数的参数名可以使任意的字符串，比如原写法里的props参数就可以换成任何p，或任何想要的名字。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var HelloMessage=(p)=&amp;gt; &amp;lt;div&amp;gt;Hello {p.name}, {p.year}!&amp;lt;/div&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;因此，当看到一个箭头函数时，判断其参数是否使用解构显得格外重要。判断的依据就是，解构变量需要被包含在花括号内。&lt;/p&gt;
&lt;h3&gt;本文示例&lt;/h3&gt;
&lt;p&gt;本文的示例可以在&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;示例代码&lt;/a&gt;中的demo6目录中找到。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React系列之五－ES6语法编写组件]]></title><description><![CDATA[从前面到文章可以知道，当我们想要编写react组件时，就需要调用React.createClass方法，这是创建组件的常用方法，但除此之外，还有两种写法经常出现在开源代码中，那就是ES6写法和stateless写法。 ES6写法 顾名思义，这种就是利用ES…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160301-react-part-5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160301-react-part-5/</guid><pubDate>Tue, 01 Mar 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;从前面到文章可以知道，当我们想要编写react组件时，就需要调用React.createClass方法，这是创建组件的常用方法，但除此之外，还有两种写法经常出现在开源代码中，那就是ES6写法和stateless写法。&lt;/p&gt;
&lt;h3&gt;ES6写法&lt;/h3&gt;
&lt;p&gt;顾名思义，这种就是利用ES6的语法来编写组件，详细的ES6语法可参考阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/&quot;&gt;ECMAScript 6入门&lt;/a&gt;，这里不再赘述。&lt;/p&gt;
&lt;p&gt;本文用ES6写法来编写上篇文章的示例，以方便比较两者之间的不同。创建index.js，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { Component} from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;
import Mixin from &amp;#39;react-mixin&amp;#39;

let mixinObject={
  componentDidMount(){
    this._alertMessage(&amp;#39;completed&amp;#39;);
  },
  _alertMessage(msg){
    alert(msg);
  }
}

class InputButton extends Component {
  constructor() {
    super()
    this.state={
      val:&amp;#39;&amp;#39;
    }
    Mixin.onClass(InputButton, mixinObject);
  }

  render(){
    var val=this.state.val;
    return(
      &amp;lt;div&amp;gt;
        &amp;lt;input ref={c=&amp;gt;this._input=c }/&amp;gt;
        &amp;lt;button onClick={this._handleClick.bind(this)}&amp;gt;go Button&amp;lt;/button&amp;gt;
        &amp;lt;p&amp;gt;input value : &amp;lt;b&amp;gt;{val}&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  }

  _handleClick(){
    this.setState({val: this._input.value})
  }
}

ReactDOM.render(
  &amp;lt;InputButton /&amp;gt;,
  document.getElementById(&amp;#39;demo5&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;两种写法的区别&lt;/h3&gt;
&lt;p&gt;可参考上篇中的写法，在这里比较两种组件写法之间的差别。为方便说明，在这里称React.createClass创建组件的写法为React写法，而利用ES6语法创建组件的写法则称为ES6写法。&lt;/p&gt;
&lt;h4&gt;组件的声明&lt;/h4&gt;
&lt;p&gt;在ES6写法中组件被看作是类，通过类的声明来创建组件，类必须要继承React.Component组件，类名就是要创建的组件名。因为是类，方法和属性之间不必添加逗号。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;class InputButton extends React.Component {}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;而React写法中，组件是React.createClass方法的返回值，由组件名是变量的名字。由于组件的属性和方法来自于一个对象，因此需要用逗号隔开。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var InputButton=React.createClass({})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;state的初始化&lt;/h4&gt;
&lt;p&gt;在ES6写法中，初始化的工作要放在类的构造函数里，即constructor方法。在构造函数中，只需对this.state赋值一个对象就完成来state的初始化。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;constructor() {
    super()
    this.state={
      val:&amp;#39;&amp;#39;
    }
 }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt; 在React写法中，初始化state则需要用getInitialState方法。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;getInitialState(){
   return { val: &amp;#39;&amp;#39;}
 }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;在ES6写法里，假如类有父类，则构造函数第一句必须是super()，用来初始化父类的相关信息，否则会出错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;props的默认值&lt;/h4&gt;
&lt;p&gt;ES6的类声明中，无法设置props的默认值，只能在类的主体之外，使用defaultProps属性，来完成对默认值的设置。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;class InputButton extends React.Component{...}
InputButton.defaultProps = { initialCount: 0 };&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;在React写法中，通过getDefaultProps方法来完成默认值的设置。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;	getDefaultProps(){
		return { initialCount: 0 };
	}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;propTypes的写法&lt;/h4&gt;
&lt;p&gt;在&lt;a href=&quot;/20150712-react-part-1&quot;&gt;此系列文章第一篇&lt;/a&gt;)我们提到了propTypes，它可以对组件所需要的属性做验证，从而让组件的调用方了解如何正确使用该组件，当时的React写法是：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;propTypes:{
    year: PropTypes.number.isRequired
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;而ES6的写法与设置props的默认值类似，需要在类的主体之外，用propTypes属性来设置，写法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;class InputButton extends React.Component{...}
InputButton.propTypes = {
	year: PropTypes.number.isRequired
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h4&gt;对mixin的支持&lt;/h4&gt;
&lt;p&gt;&lt;a href=&quot;/20160104-react-part-4&quot;&gt;上篇文章&lt;/a&gt;中，我们用React写法创建的组件中通过设置mixins属性，添加了mixin功能，让两个不相干的类之间也能共享属性和方法。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var InputButton=React.createClass({
  mixins:[mixinObject],
  getInitialState(){
    return { val: &amp;#39;&amp;#39;}
  },&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可惜的是，ES6写法目前并不支持mixin，只能通过第三方的组件来实现mixin。本例中使用了react-mixin组件来添加mixin功能，写法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import Mixin from &amp;#39;react-mixin&amp;#39;
class InputButton extends Component {
  constructor() {
    super()
    this.state={
      val:&amp;#39;&amp;#39;
    }
    Mixin.onClass(InputButton, mixinObject);
  }  &lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt; 除此之外，还有其他的第三方组件提供mixin功能，而且在不久的将来，ES7的语法中也会加入了对mixin的支持。所以从目前来看，当你需要mixin功能的组件时，选择React写法会比较有利。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt; react－mixin组件的详细信息可&lt;a href=&quot;https://github.com/brigand/react-mixin&quot;&gt;点击此处查看&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;方法绑定this&lt;/h4&gt;
&lt;p&gt;在本例的ES6写法中，button控件的onClick事件和React写法略有不同，在方法的最后多了.bind(this)。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;button onClick={this._handleClick.bind(this)}&amp;gt;go Button&amp;lt;/button&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;bind是javscript自带的方法，bind(this)的作用是为了让对应方法的内部实现能通过this引用到当前组件的实例。所以在本例中是为了让_handleClick方法内部能够使用this.setState方法。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;_handleClick(){
    this.setState({val: this._input.value})
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;相似的写法还有this.props，this.state等等，假如组件中的方法内部通过this引用了实例的属性和方法，在ES6写法中就必须在最后添加.bind(this)，否则会出错。&lt;/p&gt;
&lt;p&gt;React写法不需要bind(this)，因为React.createClass()会将参数对象中的所有方法都自动绑定.bind(this)，换言之，React写法也需要绑定this，但createClass帮我们做了绑定的逻辑，省去了手工编写的麻烦。&lt;/p&gt;
&lt;p&gt;但是假如方法内部的方法也需要引用组件示例的方法（比如this.setState）该怎么办？这种情况createClass不能帮忙自动绑定，只能自己手动操作。在之前的&lt;a href=&quot;http://twomeetings.github.io/2016/03/03/React%E7%B3%BB%E5%88%97%E4%B9%8B%E4%B8%89%EF%BC%8D%E4%BA%8B%E4%BB%B6/&quot;&gt;系列文章－组件的事件&lt;/a&gt;中，有一段jQuery异步请求的代码，在回调函数中使用了this.setState，所以在方法后面添加了.bind(this)。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;$.ajax({
        type: &amp;quot;GET&amp;quot;,
        dataType: &amp;#39;jsonp&amp;#39;,
        url: url
      }).done(function(json){
        var rating = json.rating.average;
        this.setState({rating:rating});
      }.bind(this));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;本文的代码可查看&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;示例代码&lt;/a&gt;的demo5目录。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[webpack系列之五－与react框架结合]]></title><description><![CDATA[前四篇文章介绍了webpack基本的使用之后，这一篇逐步演示一个webpack结合react的项目，其中只包含react最基本的使用，所以没用过react的不必担心。当然，也可以通过react…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160226-webpack-part-5/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160226-webpack-part-5/</guid><pubDate>Fri, 26 Feb 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;前四篇文章介绍了webpack基本的使用之后，这一篇逐步演示一个webpack结合react的项目，其中只包含react最基本的使用，所以没用过react的不必担心。当然，也可以通过&lt;a href=&quot;http://twomeetings.github.io/2016/05/08/%E4%B8%AA%E4%BA%BA%E5%8D%9A%E6%96%87%E6%B1%87%E6%80%BB/&quot;&gt;react系列文章&lt;/a&gt;查看其用法。&lt;/p&gt;
&lt;h3&gt;初始化项目&lt;/h3&gt;
&lt;p&gt;首先，在一个目录下初始化项目，执行以下命令，然后一路回车到底。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm init&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;初始化时不要将项目名称命名为模块名，比如react，这样会导致下面的react安装出错。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;假如没有安装过webpack的，需要先将webpack安装到全局环境，可顺便在此处连简易服务器组件webpack-dev-server一起安装，该组件说明可在&lt;a href=&quot;http://twomeetings.github.io/2016/01/05/Webpack%20%E7%B3%BB%E5%88%97%E5%BC%80%E7%AF%87%E4%B8%80/&quot;&gt;系列文章第一篇&lt;/a&gt;找到。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install webpack webpack-dev-server -g&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;添加webpack配置文件&lt;/h3&gt;
&lt;p&gt;添加配置文件webpack.config.js,将index.js做为模块入口，且用加载器babel-loader来处理js文件，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports={
  entry:&amp;#39;./index.js&amp;#39;,
  output:{
    path: __dirname+&amp;#39;/dist&amp;#39;,
    filename: &amp;quot;bundle_[name].js&amp;quot;
  },
  module:{
    loaders:[
      {test: /\.jsx?$/, loader:&amp;quot;babel&amp;quot;}
    ]
  }
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;配置文件内各节点的含义可查阅&lt;a href=&quot;/20160115-webpack-part-2&quot;&gt;系列文章第二篇&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;安装react相关的组件&lt;/h3&gt;
&lt;p&gt;为了让react能运作正常，除了加载器babel-loader，还需要另外两个插件babel-preset-es2015，babel-preset-react，前者用来支持ES6语法，后者则是支持react语法，安装命令如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install babel-loader babel-preset-es2015 babel-preset-react --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这两个语法插件需写在配置文件中才能生效，像这样：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
    {test: /\.jsx?$/, loader:&amp;quot;babel&amp;quot;, query : { presets:[&amp;#39;es2015&amp;#39;,&amp;#39;react&amp;#39;]}}
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;或者也可添加一个名为.babelrc的文件，填入以下内容，编译时该文件会被自动加载。两种方法都可，这里我们采用后者。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{
  &amp;quot;presets&amp;quot;:[&amp;quot;es2015&amp;quot;, &amp;quot;react&amp;quot;]
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;假如不使用babel-preset-es2015，es6的语法（如import）将无法被识别。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;现在所有准备工作就绪，我们现在执行安装命令引入react，当前版本的react推荐使用react-dom来操作html元素，所以要一并安装&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install react react-dom --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;编写React代码&lt;/h3&gt;
&lt;p&gt;添加入口文件index.js，编写一个名为HelloWorld的组件，在”id＝react-div”的html元素上呈现一段文字，代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

var HelloWorld=React.createClass({
  render(){
    return(
      &amp;lt;p&amp;gt;Hello World, Hello React. &amp;lt;/p&amp;gt;
    )
  }
})

ReactDOM.render(
  &amp;lt;HelloWorld /&amp;gt;,
  document.getElementById(&amp;#39;react-div&amp;#39;)
)	&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;现在只需一个包含id为react-div元素的html页面就可以看到最终效果，我们可以手动添加，也可以利用&lt;a href=&quot;/20160119-webpack-part-3&quot;&gt;系列文章第三篇&lt;/a&gt;中谈及的模板插件来创建页面。&lt;/p&gt;
&lt;h3&gt;模版插件添加HTML页面&lt;/h3&gt;
&lt;p&gt;安装模版插件html-webpack-plugin，因为其依赖webpack，所以要一并安装，执行命令如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install webpack html-webpack-plugin --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;修改配置文件为如下所示：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var HtmlWebpackplugin=require(&amp;#39;html-webpack-plugin&amp;#39;);

module.exports={
  entry:{
    index : &amp;#39;./index.js&amp;#39;
  },
  output:{
    path: __dirname+&amp;#39;/dist&amp;#39;,
    filename: &amp;quot;bundle_[name].js&amp;quot;
  },
  module:{
    loaders:[
      {test: /\.jsx?$/, exclude:/node_modules/, loader:&amp;quot;babel&amp;quot;}
    ]
  },
  plugins:[
    new HtmlWebpackplugin({title:&amp;#39;Index Page&amp;#39;, template:&amp;#39;template.html&amp;#39;, filename:&amp;#39;index.html&amp;#39;, chunks:[&amp;#39;index&amp;#39;]})
  ]
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;添加模板文件template.html:&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div id=&amp;#39;react-div&amp;#39;&amp;gt;&amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;执行编译命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;编译成功后，再执行下面命令启动简易服务器。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack-dev-server&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;最后，就可以通过浏览器访问服务器默认地址 &lt;a href=&quot;http://localhost:8080/webpack-dev-server/&quot;&gt;http://localhost:8080/webpack-dev-server/&lt;/a&gt; 查看效果。&lt;/p&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;这样一个webpack和react相结合的项目就搭建完成，假如你按上面步骤操作碰到了问题，可直接到&lt;a href=&quot;https://github.com/twomeetings/webpackAndReact&quot;&gt;这里&lt;/a&gt;下载示例代码。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[webpack系列之四－资源文件的整合]]></title><description><![CDATA[css的提取和合并 在webpack模版插件下，可以对css做提取和合并成一个文件，从而达到优化性能和方便管理的目的。比如我们现在需要index.js文件中引入两个css文件： 提取和合并的工作就需要用到插件‘extract-text-webpack-plugin…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160208-webpack-part-4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160208-webpack-part-4/</guid><pubDate>Mon, 08 Feb 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;css的提取和合并&lt;/h3&gt;
&lt;p&gt;在webpack模版插件下，可以对css做提取和合并成一个文件，从而达到优化性能和方便管理的目的。比如我们现在需要index.js文件中引入两个css文件：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;require(&amp;#39;./main.css&amp;#39;);
require(&amp;#39;./common.css&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;提取和合并的工作就需要用到插件‘extract-text-webpack-plugin’，安装代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install extract-text-webpack-plugin --save-dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;首先在配置文件中该插件，并创建一个实例。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var ExtractTextWebpackPlugin=require(&amp;#39;extract-text-webpack-plugin&amp;#39;);
var extractCss = new ExtractTextWebpackPlugin(&amp;#39;[name].css&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;[name]类似output配置节中的变量，等于对应模块的名称，其他几个变量可在&lt;a href=&quot;https://github.com/webpack/extract-text-webpack-plugin&quot;&gt;对应网站&lt;/a&gt;查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;然后，我们需要修改module的loaders配置节中针对css文件的部分，如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{test: /\.css$/, loader: extractCss.extract(&amp;#39;style&amp;#39;,&amp;#39;css&amp;#39;)}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;最后在plugins配置节加入这个插件的实例。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;plugins:[
	...,
	extractCss,
	...
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;运行编译命令：webpack。编译后的文件就多来一个index.css,这个文件的内容合并main.css和common.css的内容。而且模版生成的html页面里，head标签自动加入了css引用的代码，省去了手工处理的麻烦，如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;link href=&amp;quot;index.css&amp;quot; rel=&amp;quot;stylesheet&amp;quot;&amp;gt;&amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;如前面提到的，通过这样的处理不但让css文件方便管理之外，还减少了请求次数，提高了性能。&lt;/p&gt;
&lt;p&gt;css和img的抽取&lt;/p&gt;
&lt;h3&gt;图片的提取&lt;/h3&gt;
&lt;p&gt;假如项目中需要用到图片该怎么处理呢？比如现在我们在模版文件用img标签来引入一张图片。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;img src=&amp;quot;./image/what-is-webpack.png&amp;quot; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;现在在项目下添加img目录，并在其中放入一张图片(what-is-webpack.png)。然后我们在index.js这个入口文件加入引用代码。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import &amp;#39;./imgs/what-is-webpack.png&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后我们用最基本的文件加载器file-loader处理图片，安装命令如下:&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install file-loader --save-dev&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后在配置文件的module字段区域添加如下代码，其中name=[name].[ext]表示编译时命名文件的规则。 &lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{test: /\.png$/, loader:&amp;#39;file?name=[name].[ext]&amp;#39;}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt; [name]和[ext]是其内置的变量，除此之外还有[path]，[hash]等，详细的说明可到&lt;a href=&quot;https://github.com/webpack/file-loader&quot;&gt;对应网站&lt;/a&gt;查询&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;执行webpack命令进行编译，图片就会出现在发布目录下。假如你想把图片放在某个目录下，只要像下面代码，在前面加目录名就行了。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{test: /\.png$/, loader:&amp;#39;file?name=image/[name].[ext]&amp;#39;}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;示例代码如下&lt;/h3&gt;
&lt;p&gt;本文代码可在&lt;a href=&quot;https://github.com/twomeetings/webpackPluginExtension&quot;&gt;此处&lt;/a&gt;查看。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[webpack系列之三 - 插件的使用]]></title><description><![CDATA[webpack框架内置了20多种插件，除此之外的开源社区也存在很多优秀的第三方插件，利用这些插件可以轻松扩展webpack到功能，给使用者带来极大的便利。 在web开发中，模版文件基本不可或缺，它抽取出通用部分，为编写代码节省了大量的时间。在webpack…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160119-webpack-part-3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160119-webpack-part-3/</guid><pubDate>Tue, 19 Jan 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;webpack框架内置了20多种插件，除此之外的开源社区也存在很多优秀的第三方插件，利用这些插件可以轻松扩展webpack到功能，给使用者带来极大的便利。&lt;/p&gt;
&lt;p&gt;在web开发中，模版文件基本不可或缺，它抽取出通用部分，为编写代码节省了大量的时间。在webpack中也有模版文件的功能，不过它是通过第三方插件来实现的，这个插件叫HtmlWebpackPlugin。可通过下面命令安装：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install html-webpack-plugin --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;现在我们通过这个插件来创建index页面。先在一个目录下初始化项目:&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm init&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后创建一个模块入口文件index.js。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// add index.js
console.log(&amp;#39;index&amp;#39;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后我们来创建模版文件template.html。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;title&amp;gt;&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
  &amp;lt;body&amp;gt;
    &amp;lt;div&amp;gt;
    	&amp;lt;h2&amp;gt;&amp;lt;%- htmlWebpackPlugin.options.title %&amp;gt;&amp;lt;/h2&amp;gt;
    &amp;lt;/div&amp;gt;
  &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;模版文件中有一句表达式&amp;#x3C;%- htmlWebpackPlugin.options.title %&gt;，用来显示某个对象点title属性，这个属性就来自于webpack与HtmlWebpackPlugin插件相关的配置节点。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 创建 webpack.config.js
module.exports={
 entry:&amp;#39;./index.js&amp;#39;,
 output:{
   path: __dirname,
   filename: &amp;quot;bundle_[name].js&amp;quot;
 },
 plugins:[
 	new HtmlWebpackPlugin({title:&amp;#39;Index Page&amp;#39;,template:&amp;#39;template.html&amp;#39;,filename:&amp;#39;index.html&amp;#39;, chunks:[&amp;#39;index&amp;#39;]})
 ]
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;可以看到对应的index模块中模版插件的title值为‘Index Page’。&lt;/p&gt;
&lt;p&gt;现在执行编译命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;当前目录下生成index.html文件，用浏览器打开如下：&lt;/p&gt;
&lt;h3&gt;添加新的页面&lt;/h3&gt;
&lt;p&gt;在当前模版下，添加页面变的容易许多，比如我们添加的页面叫basic。首先添加模版入口文件basic.js，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;console.log(&amp;#39;basic&amp;#39;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;之后修改配置文件的entry属性，加入basic模块。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;entry:{
	index: &amp;#39;./index.js&amp;#39;,
	basic: &amp;#39;./basic.js&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后添加一个新的HtmlWebPackPlugin插件给basic模块。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;plugins:[
  	new HtmlWebpackPlugin({title:&amp;#39;Index Page&amp;#39;,template:&amp;#39;template.html&amp;#39;,filename:&amp;#39;index.html&amp;#39;, chunks:[&amp;#39;index&amp;#39;]})
  ],
  	new HtmlWebpackPlugin({title:&amp;#39;Basic Page&amp;#39;,template:&amp;#39;template.html&amp;#39;,filename:&amp;#39;basic.html&amp;#39;, chunks:[&amp;#39;basic&amp;#39;]})
  ]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;执行编译命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这样以basic.js为模块的basic.html页面就添加好了。&lt;/p&gt;
&lt;h3&gt;模板变量&lt;/h3&gt;
&lt;p&gt;该模板插件中内置了一些变量，可以通过“&amp;#x3C;%= %&gt;”来引用，当需要对变量中的内容编码时，可以使用“&amp;#x3C;%- %&gt;”。具体的模版属性可以访问&lt;a href=&quot;https://github.com/ampedandwired/html-webpack-plugin&quot;&gt;此处&lt;/a&gt;查看官方说明。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;模板编译时无法用console.log查看信息，此处通过Object.keys()的方式罗列出所有的属性参数。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;本文相关代码可在&lt;a href=&quot;https://github.com/twomeetings/webpackPluginExtension&quot;&gt;此处&lt;/a&gt;查询。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[webpack系列之二 - 配置文件解析]]></title><description><![CDATA[使用配置文件是webpack的基本用法，默认的配置文件名是webpack.config.js，只需把这个文件创建在根目录下，webpack编译时就会自动加载。 在开篇文章里，一个简单示例展示了webpack…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160115-webpack-part-2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160115-webpack-part-2/</guid><pubDate>Fri, 15 Jan 2016 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;使用配置文件是webpack的基本用法，默认的配置文件名是webpack.config.js，只需把这个文件创建在根目录下，webpack编译时就会自动加载。&lt;/p&gt;
&lt;p&gt;在开篇文章里，一个简单示例展示了webpack的基本机制和运作方式，例子中的配置文件内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports={
  entry:&amp;#39;./entry.js&amp;#39;,
  output:{
    path: __dirname,
    filename: &amp;quot;bundle.js&amp;quot;
  },
  module:{
    loaders:[
      {test: /\.css$/, loader:&amp;quot;style!css&amp;quot;}
    ]
  }
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;通过这配置文件，webpack将entry.js当作入口文件，无论其内部引用了多少js文件，jquery，angularJS，react等等，最终都会被编译并重命名为一个单独文件bundle.js, 这个单独的文件即被视为模块(在webpack中被称为chunk)。&lt;/p&gt;
&lt;h3&gt;配置字段：entry&lt;/h3&gt;
&lt;p&gt;entry可以接受三种形式的赋值，一个字符串，一个字符串数组或者一个对象。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;//字符串
entry:&amp;#39;./entry.js&amp;#39;

//字符串数组
entry:[&amp;#39;./entry1.js&amp;#39;,&amp;#39;./entry2.js&amp;#39;,&amp;#39;./entry3.js&amp;#39;]

//对象
entry:{
	name1:&amp;#39;./entry1.js&amp;#39;,
	name2:&amp;#39;./entry2.js&amp;#39;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;它们的区别是，第一种的模块名等于没有后缀的文件名，即entry。第二种会将数组中的文件全部编译到一个文件中，以最后一个文件名来命名模块名。第三种则是根据对象的字段，一个属性名对应一个模块，且属性名为模块名，上面的例子中会生成两个模块name1和name2.&lt;/p&gt;
&lt;h3&gt;配置字段：output&lt;/h3&gt;
&lt;p&gt;output用来决定输出模块的信息，比如目录或者名称。下面的代码将模块文件命名为bundle.js，并放置到当前目录下。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;output:{
    path: __dirname,
    filename: &amp;quot;bundle.js&amp;quot;
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;__dirname是nodejs中的常量，表示当前目录&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;因此这段代码&lt;/p&gt;
&lt;p&gt;所有模块输出的规则都遵守output中的配置，因此在多模块的情况下，filename为常量会造成一些问题。推荐的做法是使用变量，在output中有几个可以使用的变量来对应相应的信息。比如：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;id&lt;/li&gt;
&lt;li&gt;name&lt;/li&gt;
&lt;li&gt;hash&lt;/li&gt;
&lt;li&gt;chunkhash&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这些变量因其对应的不同模块而不同，使用时需要放到方括号中，如[id].js,[name]_bundle.js,比如下面的示例：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;entry:｛
	name1: &amp;#39;./entry1.js&amp;#39;,
	name2: &amp;#39;./entry1.js&amp;#39;
｝,
  output:{
    path: __dirname,
    filename: &amp;quot;[name]_bundle.js&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;上面的配置最终会在当前目录下生成两个模块文件name1&lt;em&gt;bundle.js和name2&lt;/em&gt;bundle.js。
你可以将四个变量都写在一起，用来查看分别代表什么值。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;filename: [id]_[name]_[hash]_[chunkhash].js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;除此之外output还有一个较常用的的字段是publicPath,用于指定文件或图片的相对路径，用于网站对访问，有别于path字段，因为后者是本地硬盘的存储路径。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;	output:{
		path:&amp;#39;/home/project/assets/&amp;#39;,
		publicPath:&amp;#39;/assets/&amp;#39;
	}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;img src=&amp;#39;/assets/pic.gif&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;在output中，除了path, filename, publicPath这三个常见字段外，还有十多个不常用的字段，在此不细说，可查阅其&lt;a href=&quot;http://www.google.com&quot;&gt;官方网站对应页面&lt;/a&gt;。&lt;/p&gt;
&lt;h3&gt;配置字段：module&lt;/h3&gt;
&lt;p&gt;module字段最核心的属性就是loaders，利用nodejs庞大的插件库，可以方便的引入专门模块来处理特殊文件，比如例子中对css文件和相应语法的处理。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;module:{
    loaders:[
      {test: /\.css$/, loader:&amp;quot;style!css&amp;quot;}
    ]
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;loaders字段接受一个数组，数组中是包含指定字段的对象。其中test值是正则表达式，用来定位什么样的文件，例中/.css$/代表以.css结尾的文件。&lt;/p&gt;
&lt;p&gt;loader表示加载器，或者叫加载模块。通常这种模块是以loader为后缀，给loader字段赋值时，可以用全名，也可省略后缀。比如style和css的全名是style-loader和css-loader，可用下面的命令来安装：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install css-loader style-loader --save&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;loader:‘style!css’表示将css和style两种加载器放到一起处理，多个加载器之间用感叹号隔开是其指定的语法，也可分开书写，便于理解。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{test: /\.css$/ , loaders:[&amp;#39;style&amp;#39;,&amp;#39;css&amp;#39;]}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;分开写在数组中需要把字段loader改成loaders&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;除此之外include和exclude也是常用的两个字段，include用来指定目录，exclude用来排除目录。当项目不断变大，模块不断变多时，模块加载器要遍历的文件也越来越多，除了导致编译速度变慢外，有时还会因为加载了不该加载的文件而报错，因此限制文件目录就变的很重要。下面的代码表示只处理app/src目录下的css文件。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;{test:/\.css$/, loaders:[&amp;#39;style&amp;#39;,&amp;#39;css&amp;#39;], include:path.resolve(__dirname,&amp;quot;app/src&amp;quot;)}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;__dirname时nodejs中的变量，表当前目录；path.resolve是nodejs内置的方法。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;而exclude最常见的用法是排除node_modules目录，因为该目录包含项目所有的第三份模块，将其排除在外可提高编译速度。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;exclude: /node_modules/&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;配置字段：plugins&lt;/h3&gt;
&lt;p&gt;webpack自身提供了一系列的插件来应对不同需求，这些插件按功能分类有30个左右，可在&lt;a href=&quot;http://webpack.github.io&quot;&gt;官网&lt;/a&gt;查询。这里用ProvidePlugin插件将jquery引用为全局变量在所有模块中使用，这样就不必在每个模块都添加引用jquery的代码。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;plugins:[
	new webpack.ProvidePlugin({
		$:&amp;#39;jquery&amp;#39;,
		jQuery:&amp;#39;jquery&amp;#39;
	})
]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;使用webpack插件要记得先在配置文件中引用webpack。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var webpack = require(&amp;#39;webpack&amp;#39;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;更多的插件相关内容，会在接下来的系列文章详细讲解。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[webpack系列－开篇]]></title><description><![CDATA[为什么要用Webpack？它是什么？ 随着nodejs的迅猛发展，javascript不断进化，且逐渐变成服务器端开发的主流，而在前端领域它能做的事情也越来越多。可是，不断增多的js代码管理起来却让人头疼，模块化是唯一的解决办法，常见的做法是将不同功能的js…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160108-webpack-part-1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160108-webpack-part-1/</guid><pubDate>Fri, 08 Jan 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;为什么要用Webpack？它是什么？&lt;/h3&gt;
&lt;p&gt;随着nodejs的迅猛发展，javascript不断进化，且逐渐变成服务器端开发的主流，而在前端领域它能做的事情也越来越多。可是，不断增多的js代码管理起来却让人头疼，模块化是唯一的解决办法，常见的做法是将不同功能的js分割作为单独模块。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;script src=&amp;quot;module1.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;module2.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
&amp;lt;script src=&amp;quot;module3.js&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;`&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;但这种做法有几点问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;全局变量可能冲突&lt;/li&gt;
&lt;li&gt;加载顺序无法保证&lt;/li&gt;
&lt;li&gt;模块之间可能存在依赖&lt;/li&gt;
&lt;li&gt;在大项目里，模块过多难以管理&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在nodejs领域，通过CommonJS规范和AMD，这些问题得到了解决。所谓CommonJS，简单来说就是可用关键字require加载模块：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var foo = require(&amp;#39;foo&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这种加载方式是同步的，在浏览器常常需异步加载，这时就涉及到了AMD的异步加载方式。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;require([&amp;quot;module&amp;quot;, &amp;quot;../file&amp;quot;], function(module, file) { /* ... */ });

define(&amp;quot;mymodule&amp;quot;, [&amp;quot;dep1&amp;quot;, &amp;quot;dep2&amp;quot;], function(d1, d2) {
  return someExportedValue;
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这解决了异步但不可避免的让代码更难阅读和维护。除此之外，随着ECMAScript6的推行，它也带来自己的模块加载方式，让模块加载这件事变的更加复杂。&lt;/p&gt;
&lt;p&gt;Webpack是一个模块化管理系统，使用它的好处有以下三点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;它可以统一模块的加载方式给开发者带来便捷。&lt;/li&gt;
&lt;li&gt;它可以利用已存在的nodejs模块，将其应用到浏览器前端。&lt;/li&gt;
&lt;li&gt;除了javascript，它可以模块化web前端相关的一切元素，图片，css，html等等。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;用webpack创建项目&lt;/h3&gt;
&lt;p&gt;首先，你需要用nodejs来安装webpack，假如对nodejs不熟悉也没有关系，将其当作是一个安装工具，常用的命令也不过3句。下载nodejs并安装后，在一个文件目录下执行如下命令，用来初始化项目。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm init&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;之后，运行下面命令安装webpack，命令后的-g，表示将其安装为全局模块：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install webpack -g&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这时可用编辑器（Atom或VsCode）打开该项目，添加以下两个文件：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 添加 entry.js
docuemnt.write(&amp;quot;It works&amp;quot;).&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 添加 index.html
&amp;lt;html&amp;gt;
    &amp;lt;head&amp;gt;
        &amp;lt;meta charset=&amp;quot;utf-8&amp;quot;&amp;gt;
    &amp;lt;/head&amp;gt;
    &amp;lt;body&amp;gt;
        &amp;lt;script type=&amp;quot;text/javascript&amp;quot; src=&amp;quot;bundle.js&amp;quot; charset=&amp;quot;utf-8&amp;quot;&amp;gt;&amp;lt;/script&amp;gt;
    &amp;lt;/body&amp;gt;
&amp;lt;/html&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;接着执行一下命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack ./entry.js bundle.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这时用浏览器打开index.html文件，你能看到”It works”显示在页面上。
&lt;img src=&quot;http://7xtbg7.com2.z0.glb.clouddn.com/webpack1-1&quot;&gt;&lt;/p&gt;
&lt;h3&gt;引用第二个文件&lt;/h3&gt;
&lt;p&gt;接着添加一个content.js文件：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 添加 content.js
module.exports= &amp;quot;It works from content.js&amp;quot;;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 修改entry.js
document.write(require(&amp;quot;./content.js&amp;quot;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;重新运行命令&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack ./entry.js bundle.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;刷新那个页面你会看到更新的内容：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;It works from content.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;第一个加载器(loader)&lt;/h3&gt;
&lt;p&gt;现在添加一个css文件，webpack本身职能处理javascript代码，所以我们需要加载器css-loader来处理css文件，同时我们需要style-loader来处理css文件中的样式。执行命令如下：
&lt;code&gt;npm install css-loader style-loader --save&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;现在做如下操作：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 添加 style.css
body{
	background: yellow;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 更新 entry.js
require(&amp;#39;!style!css!./style.css&amp;#39;);
document.write(require(&amp;#39;./content.js&amp;#39;))&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;重新执行命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack ./entry.js bundle.js&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;刷新页面，应该能看到背景色的变化。&lt;/p&gt;
&lt;h3&gt;配置文件&lt;/h3&gt;
&lt;p&gt;现在将上面对例子移动到配置文件中。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 创建 webpack.config.js
module.exports={
  entry:&amp;#39;./entry.js&amp;#39;,
  output:{
    path: __dirname,
    filename: &amp;quot;bundle.js&amp;quot;
  },
  module:{
    loaders:[
      {test: /\.css$/, loader:&amp;quot;style!css&amp;quot;}
    ]
  }
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;现在我们只要运行命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;webpack&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;webpack会尝试加载当前目录下的webpack.config.js文件，这样就可以完成编译。&lt;/p&gt;
&lt;h3&gt;监控模式&lt;/h3&gt;
&lt;p&gt;如果不想每次更改后都手动执行一下，可以在最开始执行下面的命令：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;wepack --watch&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这样webpack会自动监控每一个文件，假如有更新，则会自动重新编译。&lt;/p&gt;
&lt;h3&gt;开发服务器&lt;/h3&gt;
&lt;p&gt;使用开发服务器模块是webpack开发中不可缺少的，它会绑定一个简便服务器到localhost:8080，每次有改动会自动编译，你可以通过浏览器访问localhost:8080/webpack-dev-server/bundle来查看页面，方便调试。
开发服务器的模块名是webpack-dev-server,安装命令如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;npm install webpack-dev-server -g&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;记得也要将webpack安装在全局，此后命令行下执行webpack-dev-server即可开启服务&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;示例代码可在&lt;a href=&quot;https://github.com/twomeetings/webpackExample&quot;&gt;此处&lt;/a&gt;找到。&lt;/p&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://javascript.ruanyifeng.com/nodejs/module.html&quot;&gt;http://javascript.ruanyifeng.com/nodejs/module.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://webpack.github.io/docs/motivation.html&quot;&gt;http://webpack.github.io/docs/motivation.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;http://webpack.github.io/docs/tutorials/getting-started/&quot;&gt;http://webpack.github.io/docs/tutorials/getting-started/&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item><item><title><![CDATA[React系列之四－扩展知识点ref和mixin]]></title><description><![CDATA[React系列之四－扩展知识点ref和mixin 在创建完组件后，我们常常需要获得对内部某个控件的值，比如说在系列文章第二篇中，我们在下拉框的onChange事件中获取并保存了下拉框的值，而获取值的途径是通过方法参数的属性：event.target.value…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20160104-react-part-4/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20160104-react-part-4/</guid><pubDate>Mon, 04 Jan 2016 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;React系列之四－扩展知识点ref和mixin&lt;/h3&gt;
&lt;p&gt;在创建完组件后，我们常常需要获得对内部某个控件的值，比如说在&lt;a href=&quot;/20150721-react-part-2&quot;&gt;系列文章第二篇中&lt;/a&gt;，我们在下拉框的onChange事件中获取并保存了下拉框的值，而获取值的途径是通过方法参数的属性：event.target.value，代码如下。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;_handleChange(event){
    this.setState({selectedColor: event.target.value});
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这是onChange事件提供的关于控件自身相关的参数。那么，假如我想在一个控件的事件中获取另外一个控件的值该怎么办？比如说，点击一个按钮，获取并保存其另一个输入框的值，这种情况下，通过事件内部的参数是读取不到的，而解决的办法是－ref属性。&lt;/p&gt;
&lt;h3&gt;ref属性用法&lt;/h3&gt;
&lt;p&gt;现在创建一个包含输入框和按钮的组件，添加index.js文件，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

var InputButton=React.createClass({
  getInitialState(){
    return { val: &amp;#39;&amp;#39;}
  },
  render(){
    var val=this.state.val;
    return(
      &amp;lt;div&amp;gt;
        &amp;lt;input ref={c=&amp;gt;this._input=c }/&amp;gt;
        &amp;lt;button onClick={this._handleClick}&amp;gt;Go&amp;lt;/button&amp;gt;
        &amp;lt;p&amp;gt;input value : &amp;lt;b&amp;gt;{val}&amp;lt;/b&amp;gt;&amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  },
  _handleClick(){
    this.setState({val: this._input.value})
  }
})

ReactDOM.render(
  &amp;lt;InputButton /&amp;gt;,
  document.getElementById(&amp;#39;demo4&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;代码中input控件包含了一个ref属性，这个属性的须是方法，且该方法的第一个参数已经指明，就是这个控件本身。代码中将这个参数赋值给了实例的_input属性，从而可以让其他控件的事件方法内调用。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;input ref={c=&amp;gt;this._input=c }/&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;在react的早期可以给ref赋值字符串，比如某个控件的Id，这样也能到达相同的效果，但随着react版本的升级，给ref属性赋值字符串的方式不再推荐。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;“c=&gt;this._input=c” 这种写法是ES6对javascript函数语法的扩张，详情可参考&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/function#%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;mixins属性用法&lt;/h3&gt;
&lt;p&gt;假如你有使用过Ruby语言，对mixin这个单词就不会陌生，它巧妙的让ruby语言拥有多重继承的好处，同时避开了多重继承的复杂性。简单来说，mixin让两个不相干的类之间也能共享其通用的功能。&lt;/p&gt;
&lt;p&gt;现在，我们添加一个对象，一个自定义方法_alertMessage和一个事件方法componentDidMount, 作用是当组件加载完毕后出现弹窗信息。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var mixinObject={
  componentDidMount(){
    this._alertMessage(&amp;#39;completed&amp;#39;);
  },
  _alertMessage(msg){
    alert(msg);
  }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;然后上文中的InputButton组件可以通过mixins属性来把这个对象容纳进来。部分代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var InputButton=React.createClass({
  mixins:[mixinObject],
  getInitialState(){
    return { val: &amp;#39;&amp;#39;}
  },
  ...&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;重新刷新页面会发现组件加载完毕后会有弹窗，尽管组件本身并没有在componentDidMount事件中添加任何代码，而且InputButton组件内部也可以使用_alertMessage这个自定义方法了。&lt;/p&gt;
&lt;p&gt;无论是自定义方法还是事件方法都能过通过mixins融入到一起，而mixins属性本身接受一个数组，可一次性融入多个mixin。当有多个mixin对象存在且每个对象都在同一个事件方法（比如componentDidMount方法）中有代码逻辑时，执行顺序和mixins数组中的顺序一致，排在前面的先执行。&lt;/p&gt;
&lt;h3&gt;代码示例&lt;/h3&gt;
&lt;p&gt;本文的&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;代码示例&lt;/a&gt;在demo4目录中查找。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React系列之三 － 组件的事件]]></title><description><![CDATA[React组件从创建到注销的过程中需要经历一个生命周期，在这个周期内会触发一系列的方法事件，利用这些事件，可以让组件处理更复杂的逻辑。 使用过jquery的一定知道，jquery的一个常见用法是，当页面DOM…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20151108-react-part-3/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20151108-react-part-3/</guid><pubDate>Sun, 08 Nov 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;React组件从创建到注销的过程中需要经历一个生命周期，在这个周期内会触发一系列的方法事件，利用这些事件，可以让组件处理更复杂的逻辑。&lt;/p&gt;
&lt;p&gt;使用过jquery的一定知道，jquery的一个常见用法是，当页面DOM元素加载完成后，再开始一些逻辑操作，写法如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;$(function(){
	// do something
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;那么，这个功能在react中该怎样实现呢？答案是通过事件中的componentDidMount方法。&lt;/p&gt;
&lt;p&gt;现在我们编写一个异步加载数据的示例，当组件加载完毕后，异步请求豆瓣的图书API并在页面上显示评分，index.js代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

var AjaxGetData= React.createClass({
  getInitialState(){
    return {rating: 0}
  },
  render(){
    var rating=this.state.rating;
    return(
      &amp;lt;div&amp;gt;书籍：《满月之夜白鲸现》 的豆瓣评分：{rating}分&amp;lt;/div&amp;gt;
    )
  },
  componentDidMount(){
    var url=&amp;#39;https://api.douban.com/v2/book/6548683&amp;#39;;
	 $.ajax({
        type: &amp;quot;GET&amp;quot;,
        dataType: &amp;#39;jsonp&amp;#39;,
        url: url
      }).done(function(json){
        var rating = json.rating.average;
        this.setState({rating:rating});
      }.bind(this));

  }
})

ReactDOM.render(
  &amp;lt;AjaxGetData /&amp;gt;,
  document.getElementById(&amp;#39;demo3&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;关于豆瓣图书API文档可查阅&lt;a href=&quot;https://developers.douban.com/wiki/?title=book_v2#get_isbn_book&quot;&gt;此处&lt;/a&gt;。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;注意，在ajax请求的done方法后面多了一个bind(this)，后面文章会详细讲解此点。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;代码解析&lt;/h3&gt;
&lt;p&gt;在上面代码中可以看到，组件中多了一个componentDidMount方法，该方法在组件加载完毕后会触发，且只会触发一次。与之对应多还有一个事件方法是componentWillMount，表示组件的render方法执行前触发。&lt;/p&gt;
&lt;p&gt;假如我们在这三个方法内加入调试信息比如：console.log(方法名)，则得到这三个方法的执行顺序如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;componentWillMount
render
componentDidMount&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;前文说过，当组件的state值改变时，组件会刷新，并导致render方法重新执行。但是componentWillMount和componentDidMount只会执行一次，直至被销毁。&lt;/p&gt;
&lt;h3&gt;shouldComponentUpdate方法&lt;/h3&gt;
&lt;p&gt;shouldComponentUpdate是react组件生命周期中的一个重要方法，它觉得着是否需要刷新组件，当它返回true时则刷新组件，返回false，则不必。它默认的判断依据是state是否改变，我们也可以根据自己的需求来修改刷新条件，比如像下面这样，只有当id属性改变时，才刷新组件。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;shouldComponentUpdate(nextProps, nextState): {
  return nextState !== this.state.id;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;一旦shouldComponentUpdate返回true，确定更新，render的前后会执行另外一对事件方法，它们是componentWillUpdate和componentDidUpdate。加入调试信息，可看到组件更新导致的这四个方法的触发顺序是：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;shouldComponentUpdate
 componentWillUpdate
 render
 componentDidUpdate&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt; 其他的事件方法，可在&lt;a href=&quot;https://facebook.github.io/react/docs/component-specs.html&quot;&gt;官网此处&lt;/a&gt;查询。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;本文&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;示例代码&lt;/a&gt;可在在目录demo3中查阅。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React系列之二 － state]]></title><description><![CDATA[大多数情况下，我们创建的组件不需要用到state，只需处理props属性，然后将其呈现出来。但是有时组件中需要应对用户的输入，这时就必须用到state来保存变化的值。 我们现在创建一个含有下拉框的组件，当用户选择了下拉框时，用state记录用户选择的内容。现在创建index.js…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20150721-react-part-2/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20150721-react-part-2/</guid><pubDate>Tue, 21 Jul 2015 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;大多数情况下，我们创建的组件不需要用到state，只需处理props属性，然后将其呈现出来。但是有时组件中需要应对用户的输入，这时就必须用到state来保存变化的值。&lt;/p&gt;
&lt;p&gt;我们现在创建一个含有下拉框的组件，当用户选择了下拉框时，用state记录用户选择的内容。现在创建index.js，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
import ReactDOM from &amp;#39;react-dom&amp;#39;

var UserInput= React.createClass({
  getInitialState(){
    return {selectedColor:&amp;#39;&amp;#39;}
  },
  render(){
    var color= this.state.selectedColor;
    return(
      &amp;lt;div&amp;gt;
        &amp;lt;select onChange={this._handleChange}&amp;gt;
          &amp;lt;option value=&amp;#39;&amp;#39;&amp;gt;&amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;red&amp;#39;&amp;gt;Red&amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;blue&amp;#39;&amp;gt;Blue &amp;lt;/option&amp;gt;
          &amp;lt;option value=&amp;#39;green&amp;#39;&amp;gt;Green &amp;lt;/option&amp;gt;
        &amp;lt;/select&amp;gt;
        &amp;lt;p&amp;gt;selected color is : {color} &amp;lt;/p&amp;gt;
      &amp;lt;/div&amp;gt;
    )
  },
  _handleChange(event){
    this.setState({selectedColor: event.target.value});
  }
})

ReactDOM.render(
  &amp;lt;UserInput /&amp;gt;,
  document.getElementById(&amp;#39;demo2&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;state初始化&lt;/h3&gt;
&lt;p&gt;从代码中可以看出，UserInput组件和&lt;a href=&quot;/20150712-react-part-1&quot;&gt;上一篇&lt;/a&gt;的例子相比，多了getInitialState方法，该方法通过返回一个对象来初始化state，最终对象的属性和state属性一致。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;getInitialState(){
    return {selectedColor:&amp;#39;&amp;#39;}
  }&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;状态值的读取和props相似，不同的是要用state保留字。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var color= this.state.selectedColor;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;h3&gt;state修改&lt;/h3&gt;
&lt;p&gt;state的修改有别于以往常见的修改方法，它不是直接操作对象this.state，而是创建新的对象将原对象替换，使用方法this.setState。&lt;/p&gt;
&lt;p&gt;在示例中的onChange事件中，直接将下拉框选中的值赋予state的selectedColor属性。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;this.setState({selectedColor: event.target.value});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;event是onChange事件的参数，event.target.value是常用属性，用来读取修改后的控件参数，其他的属性可参考&lt;a href=&quot;https://facebook.github.io/react/docs/events.html#form-events&quot;&gt;官网此处&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h2&gt;props和state的比较&lt;/h2&gt;
&lt;p&gt;props和state在组件中都可以用来承载数据，不过它们是有区别的。&lt;/p&gt;
&lt;p&gt;props通常由外部调用时指定，一旦定下就不可更改，因此它常常和初始化联系到一起。不可更改的特性也意味着更好的性能。react开发中有一种开发模式就是父子组件，父组件和子组件之间的通信基本通过props。&lt;/p&gt;
&lt;p&gt;state在组件内部操作，是可变的，常常用来应对有用户输入的场景，比如本例中用来记录下拉框选中的值。每次state的值改变，整个组件就会重新呈现一次，过于频繁的改动有可能会导致性能问题。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;可查看&lt;a href=&quot;https://facebook.github.io/react/docs/interactivity-and-dynamic-uis.html#components-are-just-state-machines&quot;&gt;官方网站&lt;/a&gt;给出的使用state的建议。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;本篇的&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;示例代码&lt;/a&gt;可在demo2文件夹中查找。&lt;/p&gt;</content:encoded></item><item><title><![CDATA[React系列之一 － 开篇]]></title><description><![CDATA[前言 React是Facebook公司创建的框架，起始于2011年，起初只在其公司内部使用，在2012年应用于Instagram项目，之后于2013年5月开源。紧接着基于React框架基础上，facebook又推出来React Native框架用于Ios和Android…]]></description><link>https://gatsby-starter-blog-demo.netlify.com/20150712-react-part-1/</link><guid isPermaLink="false">https://gatsby-starter-blog-demo.netlify.com/20150712-react-part-1/</guid><pubDate>Sun, 12 Jul 2015 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;React是Facebook公司创建的框架，起始于2011年，起初只在其公司内部使用，在2012年应用于Instagram项目，之后于2013年5月开源。紧接着基于React框架基础上，facebook又推出来React Native框架用于Ios和Android应用的开发，并于2015年2月正式开源，据说开源当天就备受瞩目，在github上获得5000颗星。&lt;/p&gt;
&lt;p&gt;到我写下这篇文章为止，不到短短一年时间，react相关的框架正逐渐改变手机端开发的格局。利用react native编写的javascript代码可以同时跑在苹果和安卓系统上，根据facebook官方博客描述的广告项目中，80%的代码可以重用。学习React无疑为前端开发人员拓宽了职业道路。&lt;/p&gt;
&lt;p&gt;本系列相关的示例代码使用webpack＋react的架构，详细的配置和搭建步骤可以参考&lt;a href=&quot;/20160108-webpack-part-1&quot;&gt;Webpack系列文章的这一篇&lt;/a&gt;，本文不再赘述。&lt;/p&gt;
&lt;h3&gt;属性props&lt;/h3&gt;
&lt;p&gt;在之前的webpack和react结合的教程里，我只做了简单的示例，即在html标签中显示一段文字，在本文的例子中我们引入react中的基本元素props。&lt;/p&gt;
&lt;p&gt;首先在一个空目录下，初始化项目名reactExample，并搭建webpack和react环境，详细做法可参考前言中的链接。&lt;/p&gt;
&lt;p&gt;创建index.js文件，内容如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;

var HelloName= React.createClass({
  render(){
    var name=this.props.myName;
    return(
      &amp;lt;p&amp;gt;Hello {name}!&amp;lt;/p&amp;gt;
    )
  }
})

ReactDOM.render(
  &amp;lt;HelloName myName=&amp;#39;Jacky&amp;#39; /&amp;gt;,
  document.getElementById(&amp;#39;demo1&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这段代码有以下四点说明：&lt;/p&gt;
&lt;h4&gt;import语法&lt;/h4&gt;
&lt;p&gt;import是ES6的特性，作用类似require，作用都是引用模块，因此下面两段代码作用一样，都是引入react模块，并将其赋值为一个名为React的变量，这个变量名可以是任何符合规则的字符串。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;
// 等同于
var React = require(&amp;#39;react&amp;#39;)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;ES6中，这种引入方式对应模块的默认输出变量，但一个模块只能允许一个默认输出变量，引用其他输出变量时，需要将其变量写准确，否则会出错。import通过花括号来引用非默认变量，比如像下面这样：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import {render} from &amp;#39;react-dom&amp;#39;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;那么对应的require语句就要写成这样：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var render=require(&amp;#39;react-dom&amp;#39;).render&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;这种引用方法也很常见，假如本例的引用语句写成了这样，那么index.js文件的最后一句需要去掉ReactDOM，改成下面这样：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;render(
  &amp;lt;HelloName myName=&amp;#39;Jacky&amp;#39; /&amp;gt;,
  document.getElementById(&amp;#39;demo1&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;关于模块import和export的详细解释可参考阮一峰老师的&lt;a href=&quot;http://es6.ruanyifeng.com/#docs/module#import%E5%91%BD%E4%BB%A4&quot;&gt;ECMAScript 6 入门&lt;/a&gt;的Module章节&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;React.createClass方法&lt;/h4&gt;
&lt;p&gt;React.createClass方法可以创建自定义的组件，该说React.createClass是组件的起点，该方法接受一个对象，必不可少的核心方法是render，该方法要返回的值表示最后的输出。在本例中返回p标签及其包含对内容。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;p&amp;gt;
    &amp;lt;label&amp;gt;{name}:&amp;lt;/label&amp;gt;
    &amp;lt;input /&amp;gt;
&amp;lt;/p&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;blockquote&gt;
&lt;p&gt;除render之外的其他的方法和属性可在官网查询，在随后的文章也会详细讲解。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4&gt;ReactDOM.render方法&lt;/h4&gt;
&lt;p&gt;ReactDOM的render方法和刚刚提及的创建组件的核心方法重名，它的作用是将组件呈现在对应的HTML的DOM元素内。示例中的代码将LabelInput组件呈现在id＝demo1对HTML标签内。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;ReactDOM.render(
  &amp;lt;LabelInput labelName=&amp;#39;test1&amp;#39; /&amp;gt;,
  document.getElementById(&amp;#39;demo1&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;ReactDOM.render方法除了组件和DOM标签两个参数外，还可以接受第三个回调函数，当组件呈现或更新完毕时会执行，具体信息可查看&lt;a href=&quot;https://facebook.github.io/react/docs/top-level-api.html#reactdom.render&quot;&gt;官网&lt;/a&gt;&lt;/p&gt;
&lt;h4&gt;无需声明的props属性&lt;/h4&gt;
&lt;p&gt;在组件内部可以通过this.props访问属性值，比如在本例中我们访问了属性myName。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var name = this.props.myName;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;但这属性是从哪来的？由于javascript对象的特性，属性不必声明就可以直接使用.也就是说当你编写组件时，需要某个属性就直接引用，比如我们修改render方法，再添加一个属性year。&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;var HelloName= React.createClass({
  render(){
    var name=this.props.myName;
    var year=this.props.year;
    return(
      &amp;lt;p&amp;gt;Hello {name}! {year}&amp;lt;/p&amp;gt;
    )
  }
})&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;编译后刷新页面可发现，属性date并没有值。这是因为调用HelloName组件时，只给myName赋了值，这说明只有当调用组件时给属性赋值，其组件内部才能拿到对应的值，否则只能是undefine.&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;HelloName myName=&amp;#39;Jacky&amp;#39; /&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;那么，由于组件内部不必显示声明属性，当我们调用某个组件的时候，怎样才能知道它需要哪些属性呢？答案使用propType。&lt;/p&gt;
&lt;h3&gt;属性验证－propTypes&lt;/h3&gt;
&lt;p&gt;编写组件时，当需要某些特定类型或者必填的属性时，可以使用propTypes来完成需求。现在我们添加propTypes，year设置为数字类型且必填，改动后的index.js代码如下：&lt;/p&gt;

        &lt;deckgo-highlight-code  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React, { PropTypes } from &amp;#39;react&amp;#39;;
import ReactDOM from &amp;#39;react-dom&amp;#39;

var HelloName= React.createClass({
  propTypes:{
    year: PropTypes.number.isRequired
  },
  render(){
    var name=this.props.myName;
    var year=this.props.year;
    return(
      &amp;lt;p&amp;gt;Hello {name}! {year}&amp;lt;/p&amp;gt;
    )
  }
})

ReactDOM.render(
  &amp;lt;HelloName myName=&amp;#39;Jacky&amp;#39;/&amp;gt;,
  document.getElementById(&amp;#39;demo1&amp;#39;)
)&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
      
&lt;p&gt;更新后查看页面，会在控制台看到异常如下：&lt;/p&gt;
&lt;p&gt;&lt;code&gt;bundle_demo1.js:1074 Warning: Failed propType: Required prop &apos;year&apos; was not specified in &apos;HelloName&apos;.&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;这样在调用组件时，就能知道该组件需要什么样的属性了。PropTypes提供了一系列的验证方式，包括字符串，对象，方法，数组以及自定义验证，详细信息可点击&lt;a href=&quot;https://facebook.github.io/react/docs/reusable-components.html#prop-validation&quot;&gt;官网此处&lt;/a&gt;查看。&lt;/p&gt;
&lt;h3&gt;示例代码&lt;/h3&gt;
&lt;p&gt;示例代码可在&lt;a href=&quot;https://github.com/twomeetings/reactExamples&quot;&gt;此处&lt;/a&gt;下载，本文示例对应文件夹demo1。&lt;/p&gt;
&lt;h3&gt;参考链接&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;a href=&quot;http://www.ruanyifeng.com/blog/2015/03/react.html&quot;&gt;http://www.ruanyifeng.com/blog/2015/03/react.html&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://en.wikipedia.org/wiki/React_(JavaScript_library&quot;&gt;https://en.wikipedia.org/wiki/React_(JavaScript_library&lt;/a&gt;)&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://medium.com/react-tutorials/react-state-14a6d4f736f5#.ox10voa3x&quot;&gt;https://medium.com/react-tutorials/react-state-14a6d4f736f5#.ox10voa3x&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;</content:encoded></item></channel></rss>